!function(e){var t={};function i(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(n,r,function(t){return e[t]}.bind(null,r));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=3)}([function(e,t,i){!function(e){"use strict";class t{constructor(e,t){this.x=e,this.y=t}offset(e,i){return new t(this.x+e,this.y+i)}rect(e,t){return new n(this.x,this.y,e,t)}rectOf(e){return new n(this.x,this.y,e.width,e.height)}rectCentered(e,t){return new n(this.x-e/2,this.y-t/2,e,t)}rectTo(e){const t=Math.min(this.x,e.x),i=Math.min(this.y,e.y),r=Math.abs(this.x-e.x),o=Math.abs(this.y-e.y);return new n(t,i,r,o)}add(e){return new t(this.x+e.x,this.y+e.y)}sub(e){return new t(this.x-e.x,this.y-e.y)}distance(e){return Math.sqrt((this.x-e.x)*(this.x-e.x)+(this.y-e.y)*(this.y-e.y))}scale(e){return new t(this.x*e,this.y*e)}min(e){return new t(Math.min(this.x,e.x),Math.min(this.y,e.y))}max(e){return new t(Math.max(this.x,e.x),Math.max(this.y,e.y))}}class i{constructor(e,t){this.width=e,this.height=t}scale(e){return new i(this.width*e,this.height*e)}}class n{constructor(e,n,r,o){this.origin=new t(e,n),this.dimension=new i(r,o)}corner(){return this.origin.offset(this.dimension.width,this.dimension.height)}topRight(){return this.origin.offset(this.dimension.width,0)}bottomLeft(){return this.origin.offset(0,this.dimension.height)}middleRight(){return this.origin.offset(this.dimension.width,this.dimension.height/2)}middleLeft(){return this.origin.offset(0,this.dimension.height/2)}middleTop(){return this.origin.offset(this.dimension.width/2,0)}middleBottom(){return this.origin.offset(this.dimension.width/2,this.dimension.height)}expand(e,t){return new n(this.origin.x-e,this.origin.y-t,this.dimension.width+2*e,this.dimension.height+2*t)}shrink(e,t){return new n(this.origin.x+e,this.origin.y+t,this.dimension.width-2*e,this.dimension.height-2*t)}withSize(e){return new n(this.origin.x,this.origin.y,e.width,e.height)}withWidth(e){return new n(this.origin.x,this.origin.y,e,this.dimension.height)}withHeight(e){return new n(this.origin.x,this.origin.y,this.dimension.width,e)}moveOrigin(e,t){return new n(this.origin.x+e,this.origin.y+t,this.dimension.width-e,this.dimension.height-t)}move(e){return new n(this.origin.x+e.x,this.origin.y+e.y,this.dimension.width,this.dimension.height)}moveTo(e){return new n(e.x,e.y,this.dimension.width,this.dimension.height)}contains(e){return e.x>=this.origin.x&&e.y>=this.origin.y&&e.x<=this.corner().x&&e.y<=this.corner().y}containsRect(e){return this.contains(e.origin)&&this.contains(e.corner())}union(e){const t=this.origin.min(e.origin),i=this.corner().max(e.corner());return new n(t.x,t.y,i.x-t.x,i.y-t.y)}}const r={BACKGROUND_COLOR:{r:29,g:29,b:29},NODE_BACK_COLOR:{r:69,g:69,b:69},FRAME_BACK_COLOR:{r:85,g:112,b:85},FRAME_COLOR_ALPHA:.7,TEXT_COLOR:{r:255,g:255,b:255},BORDER_COLOR:{r:0,g:0,b:0},PROPERTY_COLOR:{r:86,g:86,b:86},HIGHLIGHT_COLOR:{r:55,g:129,b:191},SELECT_BACK_COLOR:{r:39,g:39,b:39},CHECK_BACK_COLOR:{r:102,g:102,b:102},SELECTION_COLOR:{r:196,g:139,b:67}};function o(e,t=1){return`rgb(${e.r}, ${e.g}, ${e.b}, ${t})`}function a(e,t){function i(e){return Math.max(Math.min(e,255),0)}return{r:i(e.r+t),g:i(e.g+t),b:i(e.b+t)}}var s;e.Corner=void 0,(s=e.Corner||(e.Corner={}))[s.TopLeft=1]="TopLeft",s[s.TopRight=2]="TopRight",s[s.BottomLeft=4]="BottomLeft",s[s.BottomRight=8]="BottomRight";const l=e.Corner.TopLeft|e.Corner.TopRight|e.Corner.BottomLeft|e.Corner.BottomRight;var u,d,p,c,h,m;e.Direction=void 0,(d=e.Direction||(e.Direction={}))[d.DOWN=0]="DOWN",d[d.LEFT=1]="LEFT",d[d.RIGHT=2]="RIGHT",e.Align=void 0,(u=e.Align||(e.Align={}))[u.LEFT=0]="LEFT",u[u.RIGHT=1]="RIGHT",u[u.CENTER=2]="CENTER";class b{constructor(){this.reset()}reset(){this.origin=new t(0,0),this.scale=1}move(e){this.origin=this.origin.add(e)}update(e,t){this.origin=e,this.scale=t}}class f{constructor(e,t){this.renderer=e,this.radius=t,this.hasShadow=!1,this.isFilled=!1,this.isStroked=!1,this.lineWidth=1,this.clippedBox=null,this.fillColor=o(e.theme.PROPERTY_COLOR),this.strokeColor=o(e.theme.BORDER_COLOR),this.roundCorners=l}filled(e){return this.fillColor=e,this.isFilled=!0,this}line(e){return this.lineWidth=e,this}stroke(e){return this.strokeColor=e,this.isStroked=!0,this}corners(e){return this.roundCorners=e,this}shadow(e=!0){return this.hasShadow=e,this}clipped(e){return this.clippedBox=e,this}draw(t){this.renderer.context.save(),this.isFilled&&(this.renderer.context.fillStyle=this.fillColor),this.isStroked&&(this.renderer.context.lineWidth=this.lineWidth,this.renderer.context.strokeStyle=this.strokeColor),this.renderer.context.beginPath(),this.renderer.context.moveTo(t.origin.x+t.dimension.width/2,t.origin.y),this.roundCorners&e.Corner.TopRight?(this.renderer.context.lineTo(t.corner().x-this.radius,t.origin.y),this.renderer.context.arcTo(t.corner().x,t.origin.y,t.corner().x,t.origin.y+this.radius,this.radius)):this.renderer.context.lineTo(t.corner().x,t.origin.y),this.roundCorners&e.Corner.BottomRight?(this.renderer.context.lineTo(t.corner().x,t.corner().y-this.radius),this.renderer.context.arcTo(t.corner().x,t.corner().y,t.corner().x-this.radius,t.corner().y,this.radius)):this.renderer.context.lineTo(t.corner().x,t.corner().y),this.roundCorners&e.Corner.BottomLeft?(this.renderer.context.lineTo(t.origin.x+this.radius,t.corner().y),this.renderer.context.arcTo(t.origin.x,t.corner().y,t.origin.x,t.corner().y-this.radius,this.radius)):this.renderer.context.lineTo(t.origin.x,t.corner().y),this.roundCorners&e.Corner.TopLeft?(this.renderer.context.lineTo(t.origin.x,t.origin.y+this.radius),this.renderer.context.arcTo(t.origin.x,t.origin.y,t.origin.x+this.radius,t.origin.y,this.radius)):this.renderer.context.lineTo(t.origin.x,t.origin.y),this.clippedBox&&(this.renderer.context.clip(),this.renderer.context.beginPath(),this.renderer.context.rect(this.clippedBox.origin.x,this.clippedBox.origin.y,this.clippedBox.dimension.width,this.clippedBox.dimension.height)),this.renderer.context.closePath(),this.hasShadow&&(this.renderer.context.shadowColor="black",this.renderer.context.shadowBlur=10,this.renderer.context.shadowOffsetX=0,this.renderer.context.shadowOffsetY=4),this.isFilled&&this.renderer.context.fill(),this.isStroked&&this.renderer.context.stroke(),this.renderer.context.restore()}}class g{constructor(e,t,i,n){this.context=e,this.size=t,this.theme=i,this.graphicalHelper=n,this.computeStyle()}setSize(e){this.size=e,this.computeStyle()}computeStyle(){this.context.font="16px Roboto";const e=this.context.measureText("Hp"),t=(e.actualBoundingBoxAscent+e.actualBoundingBoxDescent)/2;this.style={unit:t,headerHeight:5*t,roundRadius:t,connectorRadius:t,collapseArrowSize:2*t,snapSize:3*t}}setProjection(e){this.context.scale(e.scale,e.scale),this.context.translate(-e.origin.x,-e.origin.y)}getPosition(e,i){return new t(e.origin.x+i.x/e.scale,e.origin.y+i.y/e.scale)}clearScreen(e){this.context.fillStyle=o(e),this.context.fillRect(0,0,this.size.width,this.size.height)}drawGrid(e,i,n,r,s){const l=this.getPosition(e,new t(0,0)).rectTo(this.getPosition(e,new t(this.size.width,this.size.height)));let u=10*s,d=n;this.context.lineWidth=1;for(let e=0;e<s;++e){this.context.strokeStyle=o(a(i,u)),this.context.beginPath();let t=Math.round(l.origin.x/d);for(let i=t*d;i<l.corner().x;i+=d,++t)0==t||e<s-1&&t%r==0||(this.context.moveTo(i,l.origin.y),this.context.lineTo(i,l.corner().y));t=Math.round(l.origin.y/d);for(let i=t*d;i<l.corner().y;i+=d,++t)0==t||e<s-1&&t%r==0||(this.context.moveTo(l.origin.x,i),this.context.lineTo(l.corner().x,i));this.context.stroke(),d*=r,u-=10}}drawConnection(e,t,i){const n=(t.x-e.x)/3;this.context.beginPath(),this.context.moveTo(e.x,e.y),this.context.bezierCurveTo(e.x+n,e.y,t.x-n,t.y,t.x,t.y),this.context.lineWidth=6,this.context.strokeStyle=o(a(this.theme.BORDER_COLOR,-20)),this.context.stroke(),this.context.lineWidth=4,this.context.strokeStyle=o(i),this.context.stroke()}drawArrow(t,i,n,r){this.context.save(),this.context.translate(t.x,t.y),n==e.Direction.RIGHT?this.context.rotate(-Math.PI/2):n==e.Direction.LEFT&&this.context.rotate(Math.PI/2),this.context.fillStyle=r,this.context.beginPath(),this.context.moveTo(-i/2,-i/2),this.context.lineTo(i/2,-i/2),this.context.lineTo(0,i/2),this.context.closePath(),this.context.fill(),this.context.restore()}roundBox(e=this.style.roundRadius){return new f(this,e)}drawText(t,i,n,r=e.Align.LEFT){if(this.context.fillStyle=i,r==e.Align.RIGHT){const e=this.context.measureText(n).width;t=t.offset(-e,0)}else if(r==e.Align.CENTER){const e=this.context.measureText(n).width;t=t.offset(-e/2,0)}this.context.fillText(n,t.x,t.y)}drawCheckMark(e,t){this.context.lineWidth=3,this.context.strokeStyle=t,this.context.beginPath(),this.context.moveTo(e.x+.5*this.style.unit,e.y+1.5*this.style.unit),this.context.lineTo(e.x+1.25*this.style.unit,e.y+2.25*this.style.unit),this.context.lineTo(e.x+2.5*this.style.unit,e.y+.5*this.style.unit),this.context.stroke()}checkboxRect(e){return new n(e.x,e.y,3*this.style.unit,3*this.style.unit)}drawCheckBox(e,t){this.roundBox().filled(o(t?this.theme.HIGHLIGHT_COLOR:this.theme.CHECK_BACK_COLOR)).draw(e),t&&this.drawCheckMark(e.origin,o(this.theme.TEXT_COLOR))}drawConnector(e,t){this.context.fillStyle=t,this.context.lineWidth=1,this.context.strokeStyle=o(this.theme.BORDER_COLOR),this.context.beginPath(),this.context.arc(e.x,e.y,this.style.connectorRadius,0,2*Math.PI),this.context.closePath(),this.context.fill(),this.context.stroke()}drawSelection(e){this.context.strokeStyle=o(this.theme.NODE_BACK_COLOR),this.context.lineWidth=2,this.context.setLineDash([5,5]),this.context.beginPath(),this.context.rect(e.origin.x,e.origin.y,e.dimension.width,e.dimension.height),this.context.stroke(),this.context.setLineDash([])}drawImage(e,t){this.context.drawImage(e,t.origin.x,t.origin.y,t.dimension.width,t.dimension.height)}}e.ControlKey=void 0,(c=e.ControlKey||(e.ControlKey={}))[c.CtrlKey=1]="CtrlKey",c[c.AltKey=2]="AltKey",c[c.ShiftKey=4]="ShiftKey",e.SelectionMode=void 0,(p=e.SelectionMode||(e.SelectionMode={}))[p.ADD=0]="ADD",p[p.REMOVE=1]="REMOVE",p[p.REPLACE=2]="REPLACE";class y{handleMouseMove(e,t){return this}handleMouseUp(e,t){return this}handleMouseDown(e,t){return this}handleMouseWheel(e,t){return this}handleKeyUp(e,t){return this}}e.CommonValueType=void 0,(m=e.CommonValueType||(e.CommonValueType={})).INTEGER="integer",m.REAL="real",m.BOOLEAN="boolean",m.STRING="string",m.ENUM="enum",e.PropertyType=void 0,(h=e.PropertyType||(e.PropertyType={})).INPUT="INPUT",h.OUTPUT="OUTPUT";class x{addToFrame(e){this.parent&&this.parent.removeChild(this),this.parent=e,this.parent&&this.parent.addChild(this)}}class v extends x{constructor(e,t,i){super(),this.id=e,this.definition=t,this.location=i,this.collapsed=!1,this.fullWidth=0,this.properties=t.properties.map(e=>new k(e,this))}findProperty(e){return this.properties.find(t=>t.definition.id===e)}}class k{constructor(e,t){this.definition=e,this.node=t,this.connections=[],this.value=e.defaultValue}isConnected(){return this.connections.length>0}isEditable(){return!(!this.definition.editable||this.definition.type==e.PropertyType.INPUT&&this.isConnected())}getValue(){return this.value}connectTo(e){this.connections.indexOf(e)<0&&this.connections.push(e)}disconnectFrom(e){const t=this.connections.indexOf(e);t>=0&&this.connections.splice(t,1)}}class w{constructor(t,i){function n(e){return t.definition.type==e?t:i}this.from=n(e.PropertyType.OUTPUT),this.to=n(e.PropertyType.INPUT)}connect(){this.from.connectTo(this),this.to.connectTo(this)}disconnect(){this.from.disconnectFrom(this),this.to.disconnectFrom(this)}opposite(e){return this.from==e?this.to:this.to==e?this.from:null}}class C extends x{constructor(e){super(),this.label=e,this.nodes=[]}addChild(e){this.nodes.push(e)}removeChild(e){this.nodes.splice(this.nodes.indexOf(e),1)}}class T{constructor(e){this.commands=e,this.isVisual=!1}execute(){this.commands.forEach(e=>e.execute())}undo(){this.commands.forEach(e=>e.undo())}redo(){this.commands.forEach(e=>e.redo())}}class S{constructor(e){this.moves=e,this.isVisual=!0}execute(){this.moves.forEach(e=>{e.node.location=e.endPosition})}undo(){this.moves.forEach(e=>{e.node.location=e.startPosition})}redo(){this.execute()}}class R{constructor(e){this.node=e,this.isVisual=!0,this.newCollapsed=!e.collapsed}execute(){this.node.collapsed=this.newCollapsed}undo(){this.node.collapsed=!this.newCollapsed}redo(){this.execute()}}class E{constructor(e,t){this.fromProperty=e,this.toProperty=t,this.isVisual=!1}execute(){this.connection=new w(this.fromProperty,this.toProperty),this.connection.connect()}undo(){this.connection.disconnect()}redo(){this.connection.connect()}}class P{constructor(e){this.connection=e,this.isVisual=!1}execute(){this.redo()}undo(){this.connection.connect()}redo(){this.connection.disconnect()}}class B{constructor(e,t){this.nodeGroup=e,this.node=t,this.isVisual=!1}execute(){this.redo()}undo(){const e=this.nodeGroup.nodes.indexOf(this.node);this.nodeGroup.nodes.splice(e,1)}redo(){this.nodeGroup.nodes.push(this.node)}}class A{constructor(e,t,i){this.nodeGroup=e,this.nodes=t,this.frames=i,this.isVisual=!1,this.connections=[],this.frameParents=new Map,this.connections=[],t.forEach(e=>{e.properties.forEach(e=>{e.connections.forEach(e=>{this.connections.indexOf(e)<0&&this.connections.push(e)})})}),i.forEach(e=>{this.frameParents.set(e,e.parent)})}execute(){for(let[e,t]of this.frameParents.entries())t?console.log("TODO remove a frame from another frame"):this.nodeGroup.frames.splice(this.nodeGroup.frames.indexOf(e),1);this.nodeGroup.nodes=this.nodeGroup.nodes.filter(e=>this.nodes.indexOf(e)<0),this.connections.forEach(e=>e.disconnect())}undo(){for(let[e,t]of this.frameParents.entries())t?console.log("TODO UNDO remove a frame from another frame"):this.nodeGroup.frames.push(e);this.nodeGroup.nodes=this.nodeGroup.nodes.concat(this.nodes),this.connections.forEach(e=>e.connect())}redo(){this.execute()}}class M{constructor(e,t){this.property=e,this.newValue=t,this.isVisual=!1,this.oldValue=e.value}execute(){this.property.value=this.newValue}undo(){this.property.value=this.oldValue}redo(){this.execute()}}class O{constructor(e,t){this.node=e,this.dimension=t,this.isVisual=!0,this.oldWidth=e.fullWidth}execute(){this.node.fullWidth=this.dimension.width}undo(){this.node.fullWidth=this.oldWidth}redo(){this.execute()}}class L{constructor(e,t){this.nodeGroup=e,this.nodes=t,this.isVisual=!0,this.oldParents=new Map,this.frame=new C("Frame"),t.forEach(e=>this.oldParents.set(e,e.parent))}execute(){this.nodeGroup.frames.push(this.frame),this.nodes.forEach(e=>e.addToFrame(this.frame))}undo(){this.oldParents.forEach((e,t)=>t.addToFrame(e)),this.nodeGroup.frames.splice(this.nodeGroup.frames.indexOf(this.frame),1)}redo(){this.execute()}}class G{constructor(e){this.nodes=e,this.isVisual=!0,this.oldParents=new Map,e.forEach(e=>{this.oldParents.set(e,e.parent)})}execute(){this.nodes.forEach(e=>e.addToFrame(null))}undo(){this.nodes.forEach(e=>e.addToFrame(this.oldParents.get(e)))}redo(){this.execute()}}class z{constructor(e,t){this.frame=e,this.newLabel=t,this.isVisual=!0,this.oldLabel=e.label}execute(){this.frame.label=this.newLabel}undo(){this.frame.label=this.oldLabel}redo(){this.execute()}}function N(e,t,i){for(let n of e){const e=n.findConnector(t,i);if(null!=e)return e}return null}function I(t){return 0!=(t&e.ControlKey.ShiftKey)?e.SelectionMode.ADD:0!=(t&e.ControlKey.CtrlKey)?e.SelectionMode.REMOVE:e.SelectionMode.REPLACE}function H(i,n,r){return 0!=(n.specialKeys&e.ControlKey.ShiftKey)?new t(Math.ceil(i.x/r)*r,Math.ceil(i.y/r)*r):i}class V extends y{handleMouseDown(t,i){if(i.specialKeys&e.ControlKey.AltKey)return new q(i.position);for(let n of t.nodeViews.slice().reverse()){const r=n.findConnector(i.position,t.renderer.style);if(null!=r)return t.select([n],e.SelectionMode.REPLACE),new F(t,r,i.position);if(n.bounds.contains(i.position)){const e=t.renderer.style.collapseArrowSize;if(n.collapseArrowCenter.rectCentered(e,e).contains(i.position))return new K(n);if(n.labelBounds.contains(i.position))return n.isSelected||(t.select([n],I(i.specialKeys)),t.draw()),new X(i.position,n);{const e=n.propertyViews.filter(e=>e.bounds.move(n.bounds.origin).contains(i.position));if(e.length>0){const n=e[0],r=t.renderer.graphicalHelper.getPropertyHandler(n.property);return r?r.handlerMouseDown(t,i,n):this}const r=t.renderer.style.roundRadius;return n.bounds.corner().offset(-r,-r).distance(i.position)<r?new W(t,n,i.position):this}}}for(let e of t.frameViews.slice().reverse())if(e.bounds.contains(i.position))return e.isSelected||(t.select([e],I(i.specialKeys)),t.draw()),e.labelBounds.contains(i.position)?new Y(i.position,e):new X(i.position,e);return new _(t,i.position)}handleMouseWheel(e,t){const i=t.deltaY>0?1/.9:.9,n=t.position.scale(i-1);return e.updateZoom(n,i),this}handleKeyUp(e,t){const i=function(e,t){for(let i of e)if(t.key===i.key&&(t.specialKeys&i.meta)===i.meta)return i.action;return null}(e.keymap,t);return i?e.doAction(i):this}}class D{constructor(e,t){this.fromProperty=e,this.toPoint=t,this.toProperty=null}update(e,t){this.toProperty=e,this.toPoint=t}draw(e){let t=this.toPoint,i=e.renderer.theme.NODE_BACK_COLOR;null!=this.toProperty&&e.canConnect(this.fromProperty.property,this.toProperty.property)&&(t=this.toProperty.globalPosition(),i=e.renderer.theme.SELECTION_COLOR);const n=this.fromProperty.globalPosition();e.renderer.drawConnection(n,t,i)}}class F extends y{constructor(e,t,i){super(),this.fromProperty=t,this.previousConnection=null,t.isConnected()&&(this.previousConnection=t.connections[0],this.previousConnection.connection.disconnect(),this.fromProperty=this.previousConnection.opposite(t)),this.feedback=new D(this.fromProperty,i),e.addFeedback(this.feedback),e.draw()}handleMouseMove(e,t){const i=N(e.nodeViews,t.position,e.renderer.style);return this.feedback.update(i,t.position),e.draw(),this}handleMouseUp(e,t){e.removeFeedback(this.feedback);const i=N(e.nodeViews,t.position,e.renderer.style),n=null!=i&&e.canConnect(this.fromProperty.property,i.property)?new E(this.fromProperty.property,i.property):null;if(null==this.previousConnection)null!=n?e.emit(n):e.draw();else{const t=new P(this.previousConnection.connection);null==n?e.emit(t):i.property==this.previousConnection.connection.opposite(this.fromProperty.property)?this.previousConnection.connection.connect():e.emit(new T([t,n]))}return new V}handleMouseDown(e,t){return new V}}class U{constructor(e){this.fromPosition=e,this.foreground=!0,this.update(e)}draw(e){e.renderer.drawSelection(this.bounds)}update(e){this.toPosition=e,this.bounds=this.fromPosition.rectTo(this.toPosition)}}class _ extends y{constructor(e,t){super(),this.originalSelection=e.selection.slice(),this.feedback=new U(t),e.addFeedback(this.feedback),e.draw()}updateSelection(t,i){let n=t.nodeViews.filter(e=>this.feedback.bounds.containsRect(e.bounds));const r=I(i.specialKeys);r==e.SelectionMode.ADD?this.originalSelection.forEach(e=>{n.indexOf(e)<0&&n.push(e)}):r==e.SelectionMode.REMOVE&&(n=this.originalSelection.filter(e=>n.indexOf(e)<0)),t.select(n,e.SelectionMode.REPLACE)}handleMouseMove(e,t){return this.feedback.update(t.position),this.updateSelection(e,t),e.draw(),this}handleMouseUp(e,t){return this.updateSelection(e,t),e.removeFeedback(this.feedback),e.draw(),new V}handleMouseDown(e,t){return new V}}class ${constructor(e,t){this.fromPosition=e,this.toPosition=t,this.foreground=!0,this.update(e)}draw(e){e.renderer.drawSelection(this.bounds)}update(e){this.toPosition=e,this.bounds=this.fromPosition.rectTo(this.toPosition)}}class W extends y{constructor(e,t,i){super(),this.node=t,this.feedback=new $(t.bounds.origin,i),e.addFeedback(this.feedback),e.draw()}handleMouseMove(e,t){return this.feedback.update(t.position),e.draw(),this}handleMouseUp(e,t){return e.emit(new O(this.node.node,this.feedback.bounds.dimension)),e.removeFeedback(this.feedback),e.draw(),new V}handleMouseDown(e,t){return new V}}class X extends y{constructor(e,t){super(),this.startPosition=e,this.node=t}handleMouseMove(e,t){return t.position.distance(this.startPosition)>3?new j(e.selection,this.startPosition).handleMouseMove(e,t):this}handleMouseUp(e,t){return e.select([this.node],I(t.specialKeys)),e.draw(),new V}handleMouseDown(e,t){return new V}}class Y extends y{constructor(e,t){super(),this.startPosition=e,this.frame=t}handleMouseMove(e,t){return t.position.distance(this.startPosition)>3?new j(e.selection,this.startPosition).handleMouseMove(e,t):this}handleMouseUp(t,i){const n=t.openSelector(this.frame.labelBounds.middleBottom().offset(-100,0),"select-value",{value:this.frame.frame.label,valueType:{type:e.CommonValueType.STRING}});return n.result.then(e=>(t.emit(new z(this.frame.frame,e)),t.select([this.frame],I(i.specialKeys)),t.draw(),new V),()=>{}),n.state}handleMouseDown(e,t){return new V}}class j extends y{constructor(e,t){super(),this.startPosition=t,this.originalPositions=new Map,fe(e).forEach(e=>{this.originalPositions.set(e,e.bounds.origin)})}handleMouseMove(e,t){for(let[i,n]of this.originalPositions.entries()){const r=n.add(t.position.sub(this.startPosition));i.moveTo(H(r,t,e.renderer.style.snapSize))}return e.draw(),this}handleMouseUp(e,t){const i=[];for(let[n,r]of this.originalPositions.entries()){const o=H(r.add(t.position.sub(this.startPosition)),t,e.renderer.style.snapSize);i.push({node:n.node,startPosition:r,endPosition:o})}return i.length>0&&e.emit(new S(i)),new V}handleMouseDown(e,t){return new V}}class K extends y{constructor(e){super(),this.node=e}handleMouseMove(e,t){return this}handleMouseUp(e,t){return e.emit(new R(this.node.node)),new V}handleMouseDown(e,t){return new V}}class q extends y{constructor(e){super(),this.startPoint=e}handleMouseMove(e,t){return e.updatePosition(this.startPoint.sub(t.position)),e.draw(),this}handleMouseUp(e,t){return new V}handleMouseDown(e,t){return new V}}class Z{constructor(e){this.node=e,this.foreground=!0}draw(e){this.node.draw(e)}}class J extends y{constructor(e,t){super(),this.node=t,this.feedback=new Z(t),e.addFeedback(this.feedback),e.draw()}handleMouseMove(e,t){return this.node.moveTo(H(t.position,t,e.renderer.style.snapSize)),this.node.layoutNode(e.renderer),e.draw(),this}handleMouseUp(t,i){return t.removeFeedback(this.feedback),t.emit(new B(t.nodeGroup,this.node.node)),t.select([t.nodeViews.find(e=>e.node===this.node.node)],e.SelectionMode.REPLACE),t.draw(),new V}handleKeyUp(e,t){return"Escape"===t.key?(e.removeFeedback(this.feedback),e.draw(),new V):this}}function Q(e){const t={};return e.forEach(e=>{let i=t;e.categories&&e.categories.split(":").forEach(e=>{i[e]||(i[e]={}),i=i[e]}),i[e.label]=e}),function e(t){return Object.keys(t).map(i=>t[i].properties?{name:t[i].id,title:t[i].label}:{name:i,children:e(t[i])})}(t)}function ee(e){return e.range&&null!=e.range.min&&null!=e.range.max}function te(e,t){return e&&(null!=e.min&&(t=Math.max(t,e.min)),null!=e.max&&(t=Math.min(t,e.max))),t}function ie(e,t,i,n){const r=e.openSelector(t,"select-value",{value:i.value,valueType:i.definition.valueType});return r.result.then(t=>{e.emit(new M(i,t))},()=>{}),r.state}class ne extends y{constructor(e,t,i){super(),this.startEvent=e,this.bounds=t,this.property=i,this.oldValue=i.value}handleMouseUp(e,t){const i=this.property.value;return this.property.value=this.oldValue,this.oldValue!=i&&e.emit(new M(this.property,i)),new V}handleMouseMove(e,t){const i=this.property.definition.valueType,n=i.range,r=(n.max-n.min)*(t.position.x-this.startEvent.position.x)/this.bounds.dimension.width;var o,a;return this.property.value=(o=i.type,a=te(n,this.oldValue+r),"integer"==o&&(a=Math.round(a)),a),e.draw(),this}}class re extends y{constructor(e,t){super(),this.startEvent=e,this.property=t}handleMouseUp(e,t){return ie(e,this.property.globalBounds().bottomLeft(),this.property.property)}handleMouseMove(e,t){return t.screenPosition.distance(this.startEvent.screenPosition)>5?new ne(this.startEvent,this.property.bounds,this.property.property):this}}class oe extends y{constructor(e){super(),this.prop=e,this.property=e.property,this.globalBounds=this.prop.globalBounds()}handleMouseUp(e,t){const i=e.renderer.style,n=this.globalBounds.shrink(2*i.unit,0),r=n.origin.rect(3.5*i.unit,n.dimension.height),o=n.topRight().offset(3.5*-i.unit,0).rect(3.5*i.unit,n.dimension.height);if(r.contains(t.position)){const t=te(this.property.definition.valueType.range,this.property.value-1);this.property.value!=t&&e.emit(new M(this.property,t))}else{if(!o.contains(t.position))return ie(e,this.globalBounds.bottomLeft(),this.property);{const t=te(this.property.definition.valueType.range,this.property.value+1);this.property.value!=t&&e.emit(new M(this.property,t))}}return new V}}const ae={handlerMouseDown(e,t,i){const n=i.globalBounds(),r=i.property;return n.shrink(2*e.renderer.style.unit,0).contains(t.position)?ee(r.definition.valueType)?new re(t,i):new oe(i):new V},layout(e,i){const n=e.context.measureText(i.property.definition.label);i.bounds=new t(0,0).rect(n.width+3*e.style.unit,4*e.style.unit)},draw(t,i){const n=i.globalBounds(),r=t.style,a=n.shrink(2*r.unit,0).withHeight(4*r.unit);if(t.roundBox().filled(o(t.theme.PROPERTY_COLOR)).draw(a),ee(i.property.definition.valueType)){const e=i.property.definition.valueType.range,n=(i.property.value-e.min)/(e.max-e.min);t.roundBox().filled(o(t.theme.HIGHLIGHT_COLOR)).clipped(a.withWidth(a.dimension.width*n)).draw(a)}else t.drawArrow(n.middleLeft().offset(3.5*r.unit,0),r.unit,e.Direction.LEFT,o(t.theme.TEXT_COLOR,.7)),t.drawArrow(n.middleRight().offset(3.5*-r.unit,0),r.unit,e.Direction.RIGHT,o(t.theme.TEXT_COLOR,.7));t.drawText(n.origin.offset(5*r.unit,3*r.unit),o(t.theme.TEXT_COLOR),i.property.definition.label+":");const s=(Math.round(100*i.getValue())/100).toString();t.drawText(n.topRight().offset(5*-r.unit,3*r.unit),o(t.theme.TEXT_COLOR),s,e.Align.RIGHT)}},se={handlerMouseDown:(e,t,i)=>i.globalBounds().shrink(2*e.renderer.style.unit,0).contains(t.position)?ie(e,i.globalBounds().bottomLeft(),i.property):new V,layout(e,i){const n=e.context.measureText(i.property.definition.label);i.bounds=new t(0,0).rect(n.width+3*e.style.unit,4*e.style.unit)},draw(t,i){const n=i.globalBounds(),r=t.style,a=n.shrink(2*r.unit,0).withHeight(4*r.unit);t.roundBox().filled(o(t.theme.PROPERTY_COLOR)).draw(a),t.drawText(n.origin.offset(5*r.unit,3*r.unit),o(t.theme.TEXT_COLOR),i.property.definition.label+":");const s=i.getValue(),l=s?s.toString():"";t.drawText(n.topRight().offset(5*-r.unit,3*r.unit),o(t.theme.TEXT_COLOR),l,e.Align.RIGHT)}},le={handlerMouseDown(e,t,i){const n=e.openSelector(i.globalBounds().bottomLeft(),"select-tree",{nodes:(r=i.property.definition.valueType.enumValues,r.map(e=>({name:e.name,title:e.label})))});var r;return n.result.then(t=>{e.emit(new M(i.property,t.name))},()=>{}),n.state},layout(e,i){const n=e.context.measureText(i.property.definition.label);i.bounds=new t(0,0).rect(n.width+3*e.style.unit,4*e.style.unit)},draw(t,i){const n=i.globalBounds(),r=t.style,a=i.getValue(),s=n.shrink(2*r.unit,0).withHeight(4*r.unit);t.roundBox().filled(o(t.theme.SELECT_BACK_COLOR)).draw(s);const l=i.property.definition.valueType.enumValues.filter(e=>e.name==a),u=l.length>0?l[0].label:"";t.drawText(n.origin.offset(3.5*r.unit,3*r.unit),o(t.theme.TEXT_COLOR),u),t.drawArrow(n.middleRight().offset(3.5*-r.unit,0),r.unit,e.Direction.DOWN,o(t.theme.TEXT_COLOR,.7))}};class ue extends y{constructor(e){super(),this.property=e}handleMouseUp(e,t){return e.emit(new M(this.property.property,!this.property.property.value)),new V}}function de(e,t){return new n(e.x,e.y,3*t.unit,3*t.unit)}const pe={handlerMouseDown(e,t,i){const n=e.renderer.style;return de(i.globalBounds().origin.offset(2*n.unit,0),n).contains(t.position)?new ue(i):new V},layout(e,i){const n=e.context.measureText(i.property.definition.label);i.bounds=new t(0,0).rect(n.width+8*e.style.unit,4*e.style.unit)},draw(e,t){const i=t.globalBounds(),n=e.style,r=t.getValue();e.drawCheckBox(de(i.origin.offset(2*n.unit,0),n),r),e.drawText(i.origin.offset(6*n.unit,2.5*n.unit),o(e.theme.TEXT_COLOR),t.property.definition.label)}},ce={handlerMouseDown:(e,t,i)=>new V,layout(e,i){const n=e.context.measureText(i.property.definition.label);i.bounds=new t(0,0).rect(n.width+5.5*e.style.unit,4*e.style.unit)},draw(t,i){const n=i.globalBounds(),r=t.style;i.property.definition.type==e.PropertyType.INPUT?t.drawText(n.origin.offset(3.5*r.unit,3*r.unit),o(t.theme.TEXT_COLOR),i.property.definition.label):t.drawText(n.topRight().offset(4*-r.unit,3*r.unit),o(t.theme.TEXT_COLOR),i.property.definition.label,e.Align.RIGHT)}};function he(t){return t.definition.valueType.type==e.CommonValueType.INTEGER||t.definition.valueType.type==e.CommonValueType.REAL?ae:t.definition.valueType.type==e.CommonValueType.STRING?se:t.definition.valueType.type==e.CommonValueType.ENUM?le:t.definition.valueType.type==e.CommonValueType.BOOLEAN?pe:ce}class me{constructor(e,t,i){this.connection=e,this.from=t,this.to=i}opposite(e){return e===this.from?this.to:this.from}}class be{constructor(e,t){this.property=e,this.node=t,this.connections=[]}isConnected(){return this.property.isConnected()}isEditable(){return this.property.isEditable()}globalBounds(){return this.bounds.move(this.node.bounds.origin)}globalPosition(){return this.connector.add(this.node.bounds.origin)}getValue(){return this.property.getValue()}connectTo(e){this.property.connectTo(e)}disconnectFrom(e){this.property.disconnectFrom(e)}updateConnections(e){this.connections=this.property.connections.map(t=>new me(t,e.get(t.from),e.get(t.to)))}drawProperty(e,t){if(this.property.isEditable()){const t=e.graphicalHelper.getPropertyHandler(this.property);t?t.draw(e,this):(console.log("no handler for drawing",this),ce.draw(e,this))}else ce.draw(e,this);this.property.definition.linkable&&e.drawConnector(this.connector.add(t),o(e.graphicalHelper.getConnectorColor(this.property)))}drawConnector(e,t){if(this.property.definition.linkable){const i=this.connector.add(t);e.drawConnector(i,o(e.graphicalHelper.getConnectorColor(this.property)))}}}function fe(e){const t=[];return e.forEach(e=>{e.node?t.push(e):t.push(...e.getAllNodes())}),t}class ge{constructor(e){this.node=e,this.fullWidth=200,this.isSelected=!1,this.parent=null,this.previewOffset=0,this.bounds=e.location.rect(0,0),this.propertyViews=e.properties.map(e=>new be(e,this))}moveTo(e){this.node.location=e,this.updateBounds()}updateBounds(){this.bounds=this.node.location.rectOf(this.bounds.dimension)}findProperty(e){return this.node.findProperty(e)}findConnector(e,t){const i=this.propertyViews.filter(i=>{if(i.property.definition.linkable)return i.connector.add(this.bounds.origin).distance(e)<=t.connectorRadius});return i.length>0?i[0]:null}updateConnections(e){this.propertyViews.forEach(t=>t.updateConnections(e))}layoutNodeFull(i){this.propertyViews.forEach(e=>{const t=i.graphicalHelper.getPropertyHandler(e.property);t?t.layout(i,e):console.log("No handler to layout property",e)});let n=this.node.fullWidth;this.propertyViews.forEach(e=>{n=Math.max(n,e.bounds.dimension.width)}),n=Math.max(200,n);let r=i.style.headerHeight;function o(o,a){a>0&&(r+=i.style.unit/2);const s=o.bounds.dimension.height;o.bounds=new t(0,r).rect(n,s),o.connector=o.property.definition.type==e.PropertyType.INPUT?o.bounds.middleLeft():o.bounds.middleRight(),r+=s}this.propertyViews.filter(t=>t.property.definition.type==e.PropertyType.OUTPUT).forEach((e,t)=>o(e,t)),this.node.definition.preview&&(this.previewOffset=r,r+=n*this.getPreviewRatio()),this.propertyViews.filter(t=>t.property.definition.type==e.PropertyType.INPUT).forEach((e,t)=>o(e,t)),this.bounds=this.bounds.origin.rect(n,r+i.style.unit),this.labelBounds=this.bounds.withHeight(i.style.headerHeight),this.collapseArrowCenter=this.bounds.origin.offset(2*i.style.unit,2.5*i.style.unit)}getPreviewRatio(){return this.previewImage?this.previewImage.height/this.previewImage.width:2/3}drawPreview(e,t){const i=e.style,n=this.bounds.dimension.width,r=t.rect(n,n*this.getPreviewRatio()).shrink(i.unit,i.unit);if(this.previewImage){const t=this.getResizeCanvas();t.width=this.previewImage.width,t.height=this.previewImage.height,t.getContext("2d").putImageData(this.previewImage,0,0),e.drawImage(t,r)}else e.roundBox().filled(o(e.theme.PROPERTY_COLOR)).draw(r)}getResizeCanvas(){return this.resizeCanvas||(this.resizeCanvas=document.createElement("canvas")),this.resizeCanvas}updatePreview(e){this.previewImage=e}layoutNodeCollapsed(i){let n=0,r=0;this.node.properties.filter(e=>e.definition.linkable).forEach((t,i)=>{t.definition.type==e.PropertyType.INPUT?n++:r++});let o=Math.max(n,r),a=3*i.style.unit;o>4&&(a+=i.style.unit*(o-4));let s=i.context.measureText(this.node.definition.label).width+3*i.style.unit+2*a;const l=new t(a,a),u=new t(s-a,a),d=Math.PI/(1+n),p=-Math.PI/(1+r);let c=Math.PI/2+d,h=Math.PI/2+p;this.propertyViews.filter(e=>e.property.definition.linkable).forEach(t=>{t.property.definition.type==e.PropertyType.INPUT?(t.connector=l.offset(Math.cos(c)*a,-Math.sin(c)*a),c+=d):(t.connector=u.offset(Math.cos(h)*a,-Math.sin(h)*a),h+=p)}),this.bounds=this.bounds.origin.rect(s,2*a),this.labelBounds=this.bounds,this.collapseArrowCenter=this.bounds.origin.offset(a+i.style.unit,a)}layoutNode(e){this.updateBounds(),this.node.collapsed?this.layoutNodeCollapsed(e):this.layoutNodeFull(e)}draw(e){this.node.collapsed?this.drawNodeCollapsed(e):this.drawNodeFull(e)}drawNodeFull(t){const i=t.renderer,n=i.style;if(i.roundBox().filled(o(i.theme.NODE_BACK_COLOR)).shadow(null==this.parent).draw(this.bounds),i.roundBox().filled(o(i.graphicalHelper.getHeaderColor(this.node))).corners(e.Corner.TopLeft|e.Corner.TopRight).draw(this.labelBounds),i.roundBox().line(this.isSelected?3:1).stroke(o(this.isSelected?i.theme.SELECTION_COLOR:i.theme.BORDER_COLOR)).draw(this.bounds),i.drawArrow(this.collapseArrowCenter,n.collapseArrowSize,e.Direction.DOWN,o(i.theme.TEXT_COLOR,.5)),i.drawText(this.collapseArrowCenter.offset(2.5*n.unit,n.unit),o(i.theme.TEXT_COLOR),this.node.definition.label),this.node.definition.preview){const e=this.bounds.origin.offset(0,this.previewOffset);this.drawPreview(i,e)}this.propertyViews.forEach(e=>{e.drawProperty(i,this.bounds.origin)})}drawNodeCollapsed(t){const i=t.renderer,n=i.style,r=this.bounds.dimension.height/2;i.roundBox(r).filled(o(i.graphicalHelper.getHeaderColor(this.node))).shadow(null==this.parent).draw(this.bounds),i.roundBox(r).line(this.isSelected?3:1).stroke(o(this.isSelected?i.theme.SELECTION_COLOR:i.theme.BORDER_COLOR)).draw(this.bounds),i.drawArrow(this.collapseArrowCenter,n.collapseArrowSize,e.Direction.RIGHT,o(i.theme.TEXT_COLOR,.5)),i.drawText(this.collapseArrowCenter.offset(2.5*n.unit,n.unit),o(i.theme.TEXT_COLOR),this.node.definition.label),this.propertyViews.forEach(e=>{e.drawConnector(i,this.bounds.origin)})}}class ye{constructor(e){this.frame=e,this.isSelected=!1,this.parent=null}updateChildren(e){this.nodeViews=this.frame.nodes.map(t=>{const i=e.get(t);return i.parent=this,i})}getAllNodes(){const e=[];return this.nodeViews.forEach(t=>{t.node?e.push(t):e.push(...t.getAllNodes())}),e}draw(t){const i=t.renderer,n=i.style;if(this.nodeViews.length>0){let e=void 0;this.nodeViews.forEach(t=>e=e?e.union(t.bounds):t.bounds),this.bounds=e.expand(20,20).moveOrigin(0,20-n.headerHeight),this.labelBounds=this.bounds.withHeight(3*n.unit)}i.roundBox().filled(o(i.theme.FRAME_BACK_COLOR,i.theme.FRAME_COLOR_ALPHA)).shadow(null==this.parent).draw(this.bounds),i.roundBox().line(this.isSelected?3:1).stroke(o(this.isSelected?i.theme.SELECTION_COLOR:i.theme.BORDER_COLOR)).draw(this.bounds),i.drawText(this.bounds.middleTop().offset(0,3*n.unit),o(i.theme.TEXT_COLOR),this.frame.label,e.Align.CENTER)}}class xe{constructor(){this.glassPane=document.createElement("div"),this.glassPane.classList.add("selector-glass-pane","hide"),this.glassPane.addEventListener("click",e=>this.glassPaneClose(e)),this.selectorEl=document.createElement("div"),this.selectorEl.classList.add("selector"),this.glassPane.appendChild(this.selectorEl)}el(){return this.glassPane}open(e,t){return this.glassPane.classList.remove("hide"),this.selectorEl.style.left=e.x+"px",this.selectorEl.style.top=e.y+"px",this.internalOpen(e,t)}close(){this.glassPane.classList.add("hide")}glassPaneClose(e){e.target==this.glassPane&&this.close()}}class ve extends xe{constructor(){super(),this.inputElement=document.createElement("input"),this.inputElement.classList.add("value-selector"),this.inputElement.addEventListener("keyup",e=>this.keyUp(e)),this.selectorEl.appendChild(this.inputElement)}internalOpen(e,t){const{value:i,valueType:n}=t;return this.value=i,this.valueType=n,this.inputElement.value=this.value,setTimeout(()=>{this.inputElement.focus(),this.inputElement.select()},0),new Promise((e,t)=>{this.resolve=e,this.reject=t})}close(){super.close(),this.reject()}keyUp(e){this.value=this.inputElement.value;const t=this.checkError();t?this.inputElement.classList.add("error"):this.inputElement.classList.remove("error"),"Escape"==e.key?this.close():"Enter"==e.key&&(super.close(),t?this.reject():this.resolve(this.convert(this.value)))}convert(t){return this.valueType.type==e.CommonValueType.INTEGER||this.valueType.type==e.CommonValueType.REAL?Number(t):t}checkError(){return this.valueType.type==e.CommonValueType.INTEGER?this.checkInt(this.value)||this.valueType.range&&this.checkRange(this.valueType.range,this.value):this.valueType.type==e.CommonValueType.REAL&&(isNaN(Number(this.value))||this.valueType.range&&this.checkRange(this.valueType.range,this.value))}checkInt(e){const t=Number(e);return isNaN(t)||t!=Math.floor(t)}checkRange(e,t){return null!=e.min&&t<e.min||null!=e.max&&t>e.max}}class ke extends xe{constructor(){super(),this.leaves=[],this.current=[],this.selection=-1,this.inputElement=document.createElement("input"),this.inputElement.classList.add("tree-selector"),this.inputElement.addEventListener("keyup",e=>this.keyUp(e)),this.selectorEl.appendChild(this.inputElement),this.listEl=document.createElement("ul"),this.listEl.classList.add("tree-selector"),this.selectorEl.appendChild(this.listEl)}internalOpen(e,t){const{nodes:i}=t;return this.current=i,this.leaves=function(e){let t=[],i=[].concat(e);for(;i.length>0;){const e=i.shift();e.children?e.children.forEach(e=>i.push(e)):t.push(e)}return t}(this.current),this.selection=-1,this.inputElement.value="",this.update(),setTimeout(()=>this.inputElement.focus(),0),new Promise((e,t)=>{this.resolve=e,this.reject=t})}close(){super.close(),this.reject()}selectItem(e,t,i){null!=e.parentIndex?(this.current=e.children,this.update(),this.updateSelection(e.parentIndex)):e.children&&e.children.length>0?(this.current=[{name:"..",title:"..",parentIndex:t,children:this.current},...e.children],this.update(),this.updateSelection(i)):(super.close(),this.resolve(e))}keyUp(e){if("Escape"==e.key)this.close();else if("ArrowDown"==e.key)this.updateSelection(Math.min(this.selection+1,this.nodes.length-1));else if("ArrowUp"==e.key)this.updateSelection(Math.max(this.selection-1,0));else if("ArrowLeft"==e.key){if(null!=this.current[0].parentIndex){const e=this.current[0];this.current=e.children,this.update(),this.updateSelection(e.parentIndex)}}else"Enter"==e.key?this.selection>=0&&this.selectItem(this.nodes[this.selection],this.selection,0):"ArrowRight"==e.key?this.selection>=0&&null==this.current[this.selection].parentIndex&&this.current[this.selection].children&&this.current[this.selection].children.length>0&&this.selectItem(this.nodes[this.selection],this.selection,0):this.update()}filterTree(e){return this.leaves.filter(t=>t.title&&t.title.toLowerCase().indexOf(e.toLowerCase())>=0)}updateSelection(e){this.selection=e,this.elements.forEach(e=>e.classList.remove("selected")),this.selection>=0&&this.elements[this.selection].classList.add("selected")}update(){const e=this.inputElement.value,t=this.nodes;if(this.nodes=e.length>0?this.filterTree(e):this.current,this.nodes!=t){for(;this.listEl.firstChild;)this.listEl.removeChild(this.listEl.lastChild);this.elements=this.nodes.map((e,t)=>{const i=document.createElement("li");i.addEventListener("click",i=>this.selectItem(e,t,-1)),t==this.selection&&this.listEl.classList.add("selected"),this.listEl.appendChild(i);const n=document.createElement("span");return n.textContent=e.title?e.title:e.name,i.appendChild(n),i})}}}class we{constructor(){this.commands=[],this.undoIndex=-1,this.listeners=[]}emit(e){if(this.undoIndex<this.commands.length-1){const e=this.commands.length-this.undoIndex;this.commands.splice(this.undoIndex+1,e)}this.commands.push(e),this.undoIndex+=1,this.commands.length>20&&(this.commands.splice(0,this.commands.length-20),this.undoIndex=this.commands.length-1),e.execute(),this.fire(e.isVisual)}undo(){if(this.undoIndex>=0){const e=this.commands[this.undoIndex];e.undo(),this.fire(e.isVisual),this.undoIndex-=1}}redo(){if(this.undoIndex<this.commands.length-1){this.undoIndex+=1;const e=this.commands[this.undoIndex];e.redo(),this.fire(e.isVisual)}}addListener(e){this.listeners.push(e)}clear(){this.commands=[]}fire(e){this.listeners.forEach(t=>t.onStackChange(e))}}function Ce(t){let i=0;return t.altKey&&(i|=e.ControlKey.AltKey),t.shiftKey&&(i|=e.ControlKey.ShiftKey),t.ctrlKey&&(i|=e.ControlKey.CtrlKey),i}function Te(e){const i=e.target.getBoundingClientRect();return{position:new t(e.clientX-i.left,e.clientY-i.top),screenPosition:null,specialKeys:Ce(e),deltaY:e.deltaY,key:e.key}}class Se extends y{}function Re(e,t,i){const n=i*t,r=n*(1-Math.abs(e/60%2-1)),o=i-n;return e<60?{r:Math.floor(255*(n+o)),g:Math.floor(255*(r+o)),b:Math.floor(255*(0+o))}:e<120?{r:Math.floor(255*(r+o)),g:Math.floor(255*(n+o)),b:Math.floor(255*(0+o))}:e<180?{r:Math.floor(255*(0+o)),g:Math.floor(255*(n+o)),b:Math.floor(255*(r+o))}:e<240?{r:Math.floor(255*(0+o)),g:Math.floor(255*(r+o)),b:Math.floor(255*(n+o))}:e<300?{r:Math.floor(255*(r+o)),g:Math.floor(255*(0+o)),b:Math.floor(255*(n+o))}:{r:Math.floor(255*(n+o)),g:Math.floor(255*(0+o)),b:Math.floor(255*(r+o))}}const Ee=[{name:"gimp:colorize",title:"Colorize",description:"Colorize the image",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"color",type:"color",def:"#00000000",blurb:"Color",nick:"Color"}]},{name:"gimp:curve",title:"Color Curve",description:"Adjusts the color of the image with a curve",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"curve",type:"GeglCurve",def:"#00000000",blurb:"The color curve.",nick:"Curve"}]},{name:"gegl:absolute",title:"Absolute",description:"Makes each linear RGB component be the absolute of its value, fabs(input_value)",categories:"color",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:add",title:"Add",description:"Math operation add, performs the operation per pixel, using either the constant provided in 'value' or the corresponding pixel from the buffer on aux as operands. The result is the evaluation of the expression result = input + value",categories:"compositors:math",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",def:0,blurb:"global value used if aux doesn't contain data",nick:"Value"}]},{name:"gegl:alien-map",title:"Alien Map",description:"Heavily distort images colors by applying trigonometric functions to map color values.",categories:"artistic",inputs:["input"],outputs:["output"],properties:[{id:"color-model",type:"enum",elements:[{label:"RGB",value:"rgb"}],def:"rgb",blurb:"What color model used for the transformation",nick:"Color model"},{id:"cpn-1-frequency",type:"number",range:{min:0,max:20},def:1,blurb:null,nick:"Component 1 frequency"},{id:"cpn-2-frequency",type:"number",range:{min:0,max:20},def:1,blurb:null,nick:"Component 2 frequency"},{id:"cpn-3-frequency",type:"number",range:{min:0,max:20},def:1,blurb:null,nick:"Component 3 frequency"},{id:"cpn-1-phaseshift",type:"number",range:{min:0,max:360},def:0,blurb:null,nick:"Component 1 phase shift"},{id:"cpn-2-phaseshift",type:"number",range:{min:0,max:360},def:0,blurb:null,nick:"Component 2 phase shift"},{id:"cpn-3-phaseshift",type:"number",range:{min:0,max:360},def:0,blurb:null,nick:"Component 3 phase shift"},{id:"cpn-1-keep",type:"boolean",def:!1,blurb:null,nick:"Keep component 1"},{id:"cpn-2-keep",type:"boolean",def:!1,blurb:null,nick:"Keep component 2"},{id:"cpn-3-keep",type:"boolean",def:!1,blurb:null,nick:"Keep component 3"}]},{name:"gegl:antialias",title:"Scale3X Antialiasing",description:"Antialias using the Scale3X edge-extrapolation algorithm",categories:"enhance",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:apply-lens",title:"Apply Lens",description:"Simulates the optical distortion caused by having an elliptical lens over the image",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"refraction-index",type:"number",range:{min:1,max:100},def:1.7,blurb:null,nick:"Lens refraction index"},{id:"keep-surroundings",type:"boolean",def:!1,blurb:"Keep image unchanged, where not affected by the lens.",nick:"Keep original surroundings"},{id:"background-color",type:"color",def:"#00000000",blurb:null,nick:"Background color"}]},{name:"gegl:bayer-matrix",title:"Bayer Matrix",description:"Generate a Bayer matrix pattern",categories:"render",inputs:[],outputs:["output"],properties:[{id:"subdivisions",type:"int",range:{min:0,max:15},def:1,blurb:"Number of subdivisions",nick:"Subdivisions"},{id:"x-scale",type:"int",range:{min:1},def:1,blurb:"Horizontal pattern scale",nick:"X Scale"},{id:"y-scale",type:"int",range:{min:1},def:1,blurb:"Vertical pattern scale",nick:"Y Scale"},{id:"rotation",type:"enum",elements:[{label:"0°",value:"0"},{label:"90°",value:"90"},{label:"180°",value:"180"}],def:"0",blurb:"Pattern rotation angle",nick:"Rotation"},{id:"reflect",type:"boolean",def:!1,blurb:"Reflect the pattern horizontally",nick:"Reflect"},{id:"amplitude",type:"number",def:0,blurb:"Pattern amplitude (logarithmic scale)",nick:"Amplitude"},{id:"offset",type:"number",def:0,blurb:"Value offset",nick:"Offset"},{id:"exponent",type:"number",def:0,blurb:"Value exponent (logarithmic scale)",nick:"Exponent"},{id:"x-offset",type:"int",def:0,blurb:"Offset for X axis",nick:"X Offset"},{id:"y-offset",type:"int",def:0,blurb:"Offset for Y axis",nick:"Y Offset"}]},{name:"gegl:bilateral-filter",title:"Bilateral Filter",description:"Like a gaussian blur; but where the contribution for each neighbourhood pixel is also weighted by the color difference with the original center pixel. ",categories:"enhance:noise-reduction",inputs:["input"],outputs:["output"],properties:[{id:"blur-radius",type:"number",range:{min:0,max:1e3},def:4,blurb:"Radius of square pixel region, (width and height will be radius*2+1).",nick:"Blur radius"},{id:"edge-preservation",type:"number",range:{min:0,max:100},def:8,blurb:"Amount of edge preservation",nick:"Edge preservation"}]},{name:"gegl:box-blur",title:"Box Blur",description:"Blur resulting from averaging the colors of a square neighbourhood.",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"int",range:{min:0,max:1e3},def:4,blurb:"Radius of square pixel region, (width and height will be radius*2+1)",nick:"Radius"}]},{name:"gegl:brightness-contrast",title:"Brightness Contrast",description:"Changes the light level and contrast. This operation operates in linear light, 'contrast' is a scale factor around 50% gray, and 'brightness' a constant offset to apply after contrast scaling.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"contrast",type:"number",range:{min:-5,max:5},def:1,blurb:"Magnitude of contrast scaling >1.0 brighten < 1.0 darken",nick:"Contrast"},{id:"brightness",type:"number",range:{min:-3,max:3},def:0,blurb:"Amount to increase brightness",nick:"Brightness"}]},{name:"gegl:buffer-sink",title:"Buffer Sink",description:"Create a new GEGL buffer to write the resulting rendering.",categories:"programming:output",inputs:["input"],outputs:[],properties:[{id:"buffer",type:"gpointer",def:0,blurb:null,nick:"Buffer location"},{id:"format",type:"gpointer",def:0,blurb:null,nick:"babl format"}]},{name:"gegl:buffer-source",title:"Buffer Source",description:"Use an existing in-memory GeglBuffer as image source.",categories:"programming:input",inputs:[],outputs:["output"],properties:[{id:"buffer",type:"GeglBuffer",def:0,blurb:"The GeglBuffer to load into the pipeline",nick:"Input buffer"}]},{name:"gegl:bump-map",title:"Bump Map",description:'This plug-in uses the algorithm described by John Schlag, "Fast Embossing Effects on Raster Image Data" in Graphics GEMS IV (ISBN 0-12-336155-9). It takes a buffer to be applied as a bump map to another buffer and produces a nice embossing effect.',categories:"light",inputs:["aux","input"],outputs:["output"],properties:[{id:"type",type:"enum",elements:[{label:"Linear",value:"linear"},{label:"Spherical",value:"spherical"}],def:"linear",blurb:"Type of map",nick:"Type"},{id:"compensate",type:"boolean",def:!0,blurb:"Compensate for darkening",nick:"Compensate"},{id:"invert",type:"boolean",def:!1,blurb:"Invert bumpmap",nick:"Invert"},{id:"tiled",type:"boolean",def:!1,blurb:"Tiled bumpmap",nick:"Tiled"},{id:"azimuth",type:"number",range:{min:0,max:360},def:135,blurb:null,nick:"Azimuth"},{id:"elevation",type:"number",range:{min:.5,max:90},def:45,blurb:null,nick:"Elevation"},{id:"depth",type:"int",range:{min:1,max:65},def:3,blurb:null,nick:"Depth"},{id:"offset-x",type:"int",range:{min:-2e4,max:2e4},def:0,blurb:null,nick:"Offset X"},{id:"offset-y",type:"int",range:{min:-2e4,max:2e4},def:0,blurb:null,nick:"Offset Y"},{id:"waterlevel",type:"number",range:{min:0,max:1},def:0,blurb:"Level that full transparency should represent",nick:"Waterlevel"},{id:"ambient",type:"number",range:{min:0,max:1},def:0,blurb:null,nick:"Ambient lighting factor"}]},{name:"gegl:c2g",title:"Color to Grayscale",description:"Color to grayscale conversion, uses envelopes formed with the STRESS approach to perform local color-difference preserving grayscale generation.",categories:"grayscale:color",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"int",range:{min:2,max:6e3},def:300,blurb:"Neighborhood taken into account, this is the radius in pixels taken into account when deciding which colors map to which gray values",nick:"Radius"},{id:"samples",type:"int",range:{min:1,max:1e3},def:4,blurb:"Number of samples to do per iteration looking for the range of colors",nick:"Samples"},{id:"iterations",type:"int",range:{min:1,max:1e3},def:10,blurb:"Number of iterations, a higher number of iterations provides less noisy results at a computational cost",nick:"Iterations"},{id:"enhance-shadows",type:"boolean",def:!1,blurb:"When enabled details in shadows are boosted at the expense of noise",nick:"Enhance Shadows"}]},{name:"gegl:cache",title:"Cache",description:"An explicit caching node, caches results and should provide faster recomputation if what is cached by it is expensive but isn't changing.",categories:"programming",inputs:["input"],outputs:["output"],properties:[{id:"cache",type:"GeglBuffer",def:!1,blurb:"NULL or a GeglBuffer containing cached rendering results, this is a special buffer where gegl_buffer_list_valid_rectangles returns the part of the cache that is valid.",nick:"Cache"}]},{name:"gegl:cartoon",title:"Cartoon",description:"Simulates a cartoon, its result is similar to a black felt pen drawing subsequently shaded with color. This is achieved by enhancing edges and darkening areas that are already distinctly darker than their neighborhood",categories:"artistic",inputs:["input"],outputs:["output"],properties:[{id:"mask-radius",type:"number",range:{min:0,max:50},def:7,blurb:null,nick:"Mask radius"},{id:"pct-black",type:"number",range:{min:0,max:1},def:.2,blurb:null,nick:"Percent black"}]},{name:"gegl:cast-format",title:"Cast Format",description:"Cast the data between input_format and output_format, both formats must have the same bpp",categories:"core:color",inputs:["input"],outputs:["output"],properties:[{id:"input-format",type:"gpointer",def:.2,blurb:"The babl format of the input",nick:"Input format"},{id:"output-format",type:"gpointer",def:.2,blurb:"The babl format of the output",nick:"Output format"}]},{name:"gegl:cell-noise",title:"Cell Noise",description:"Generates a cellular texture.",categories:"render",inputs:[],outputs:["output"],properties:[{id:"scale",type:"number",range:{min:0,max:20},def:1,blurb:"The scale of the noise function",nick:"Scale"},{id:"shape",type:"number",range:{min:1,max:2},def:2,blurb:"Interpolate between Manhattan and Euclidean distance.",nick:"Shape"},{id:"rank",type:"int",range:{min:1,max:3},def:1,blurb:"Select the n-th closest point",nick:"Rank"},{id:"iterations",type:"int",range:{min:1,max:20},def:1,blurb:"The number of noise octaves.",nick:"Iterations"},{id:"palettize",type:"boolean",def:!1,blurb:"Fill each cell with a random color",nick:"Palettize"},{id:"seed",type:"int",def:0,blurb:"The random seed for the noise function",nick:"Random seed"}]},{name:"gegl:channel-mixer",title:"Channel Mixer",description:"Remix colors; by defining relative contributions from source components.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"preserve-luminosity",type:"boolean",def:!1,blurb:null,nick:"Preserve luminosity"},{id:"rr-gain",type:"number",range:{min:-2,max:2},def:1,blurb:"Set the red amount for the red channel",nick:"Red in Red channel"},{id:"rg-gain",type:"number",range:{min:-2,max:2},def:0,blurb:"Set the green amount for the red channel",nick:"Green in Red channel"},{id:"rb-gain",type:"number",range:{min:-2,max:2},def:0,blurb:"Set the blue amount for the red channel",nick:"Blue in Red channel"},{id:"gr-gain",type:"number",range:{min:-2,max:2},def:0,blurb:"Set the red amount for the green channel",nick:"Red in Green channel"},{id:"gg-gain",type:"number",range:{min:-2,max:2},def:1,blurb:"Set the green amount for the green channel",nick:"Green for Green channel"},{id:"gb-gain",type:"number",range:{min:-2,max:2},def:0,blurb:"Set the blue amount for the green channel",nick:"Blue in Green channel"},{id:"br-gain",type:"number",range:{min:-2,max:2},def:0,blurb:"Set the red amount for the blue channel",nick:"Red in Blue channel"},{id:"bg-gain",type:"number",range:{min:-2,max:2},def:0,blurb:"Set the green amount for the blue channel",nick:"Green in Blue channel"},{id:"bb-gain",type:"number",range:{min:-2,max:2},def:1,blurb:"Set the blue amount for the blue channel",nick:"Blue in Blue channel"}]},{name:"gegl:checkerboard",title:"Checkerboard",description:"Render a checkerboard pattern",categories:"render",inputs:[],outputs:["output"],properties:[{id:"x",type:"int",range:{min:1},def:16,blurb:"Horizontal width of cells pixels",nick:"Width"},{id:"y",type:"int",range:{min:1},def:16,blurb:"Vertical width of cells pixels",nick:"Height"},{id:"x-offset",type:"int",def:0,blurb:"Horizontal offset (from origin) for start of grid",nick:"Offset X"},{id:"y-offset",type:"int",def:0,blurb:"Vertical offset (from origin) for start of grid",nick:"Offset Y"},{id:"color1",type:"color",def:"#000000ff",blurb:"The first cell color",nick:"Color 1"},{id:"color2",type:"color",def:"#ffffffff",blurb:"The second cell color",nick:"Color 2"},{id:"format",type:"gpointer",def:"#ffffffff",blurb:"The babl format of the output",nick:"Babl Format"}]},{name:"gegl:clone",title:"Clone",description:"Clone a buffer, this is the same as gegl:nop but can get special treatment to get more human readable references in serializations/UI.",categories:"core",inputs:["input"],outputs:["output"],properties:[{id:"ref",type:"string",def:"ID",blurb:"The reference ID used as input (for use in XML).",nick:"Reference"}]},{name:"gegl:color",title:"Color",description:"Generates a buffer entirely filled with the specified color, use gegl:crop to get smaller dimensions.",categories:"render",inputs:[],outputs:["output"],properties:[{id:"value",type:"color",def:"#000000ff",blurb:"The color to render (defaults to 'black')",nick:"Color"},{id:"format",type:"gpointer",def:"#000000ff",blurb:"The babl format of the output",nick:"Babl Format"}]},{name:"gegl:color-assimilation-grid",title:"Color Assimilation Grid",description:"Turn image grayscale and overlay an oversaturated grid - through color assimilation happening in the human visual system, for some grid scales this produces the illusion that the grayscale grid cells themselves also have color.",categories:"illusions",inputs:["input"],outputs:["output"],properties:[{id:"grid-size",type:"number",range:{min:0,max:150},def:23,blurb:null,nick:"Grid size"},{id:"saturation",type:"number",range:{min:0,max:30},def:2.5,blurb:null,nick:"Saturation"},{id:"angle",type:"number",range:{min:-180,max:180},def:45,blurb:null,nick:"Angle"},{id:"line-thickness",type:"number",range:{min:0,max:1},def:.4,blurb:null,nick:"Line thickness"}]},{name:"gegl:color-enhance",title:"Color Enhance",description:"Stretch color chroma to cover maximum possible range, keeping hue and lightness untouched.",categories:"color:enhance",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:color-exchange",title:"Exchange color",description:"Exchange one color with another, optionally setting a threshold to convert from one shade to another.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"from-color",type:"color",def:"#ffffffff",blurb:"The color to change.",nick:"From Color"},{id:"to-color",type:"color",def:"#000000ff",blurb:"Replacement color.",nick:"To Color"},{id:"red-threshold",type:"number",range:{min:0,max:1},def:0,blurb:"Red threshold of the input color",nick:"Red Threshold"},{id:"green-threshold",type:"number",range:{min:0,max:1},def:0,blurb:"Green threshold of the input color",nick:"Green Threshold"},{id:"blue-threshold",type:"number",range:{min:0,max:1},def:0,blurb:"Blue threshold of the input color",nick:"Blue Threshold"}]},{name:"gegl:color-overlay",title:"Color Overlay",description:"Paint a color overlay over the input, preserving its transparency.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"value",type:"color",def:"#00000000",blurb:"The color to paint over the input",nick:"Color"},{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"gegl:color-rotate",title:"Color Rotate",description:"Replace a range of colors with another",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"src-clockwise",type:"boolean",def:!1,blurb:"Switch to clockwise",nick:"Clockwise"},{id:"src-from",type:"number",range:{min:0,max:360},def:0,blurb:"Start angle of the source color range",nick:"From"},{id:"src-to",type:"number",range:{min:0,max:360},def:90,blurb:"End angle of the source color range",nick:"To"},{id:"dest-clockwise",type:"boolean",def:!1,blurb:"Switch to clockwise",nick:"Clockwise"},{id:"dest-from",type:"number",range:{min:0,max:360},def:0,blurb:"Start angle of the destination color range",nick:"From"},{id:"dest-to",type:"number",range:{min:0,max:360},def:90,blurb:"End angle of the destination color range",nick:"To"},{id:"threshold",type:"number",range:{min:0,max:1},def:0,blurb:"Colors with a saturation less than this will treated as gray",nick:"Gray threshold"},{id:"gray-mode",type:"enum",elements:[{label:"Treat as this",value:"treat-as"}],def:"(null)",blurb:"Treat as this: Gray colors from above source range will be treated as if they had this hue and saturation\nChange to this: Change gray colors to this hue and saturation",nick:"Gray mode"},{id:"hue",type:"number",range:{min:0,max:360},def:0,blurb:"Hue value for above gray settings",nick:"Hue"},{id:"saturation",type:"number",range:{min:0,max:1},def:0,blurb:"Saturation value for above gray settings",nick:"Saturation"}]},{name:"gegl:color-temperature",title:"Color Temperature",description:"Change the color temperature of the image, from an assumed original color temperature to an intended one.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"original-temperature",type:"number",range:{min:1e3,max:12e3},def:6500,blurb:"Estimated temperature of the light source in Kelvin the image was taken with.",nick:"Original temperature"},{id:"intended-temperature",type:"number",range:{min:1e3,max:12e3},def:6500,blurb:"Corrected estimation of the temperature of the light source in Kelvin.",nick:"Intended temperature"}]},{name:"gegl:color-to-alpha",title:"Color to Alpha",description:"Convert a specified color to transparency, works best with white.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"color",type:"color",def:"#ffffffff",blurb:"The color to make transparent.",nick:"Color"},{id:"transparency-threshold",type:"number",range:{min:0,max:1},def:0,blurb:"The limit below which colors become transparent.",nick:"Transparency threshold"},{id:"opacity-threshold",type:"number",range:{min:0,max:1},def:1,blurb:"The limit above which colors remain opaque.",nick:"Opacity threshold"}]},{name:"gegl:color-warp",title:"Color warp",description:"Warps the colors of an image between colors with weighted distortion factors, color pairs which are black to black get ignored when constructing the mapping.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"from-0",type:"color",def:"#000000ff",blurb:null,nick:"From 0"},{id:"to-0",type:"color",def:"#000000ff",blurb:null,nick:"To 0"},{id:"weight-0",type:"number",def:100,blurb:null,nick:"weight 0"},{id:"from-1",type:"color",def:"#000000ff",blurb:null,nick:"From 1"},{id:"to-1",type:"color",def:"#000000ff",blurb:null,nick:"To 1"},{id:"weight-1",type:"number",def:100,blurb:null,nick:"weight 1"},{id:"from-2",type:"color",def:"#000000ff",blurb:null,nick:"From 2"},{id:"to-2",type:"color",def:"#000000ff",blurb:null,nick:"To 2"},{id:"weight-2",type:"number",def:100,blurb:null,nick:"weight 2"},{id:"from-3",type:"color",def:"#000000ff",blurb:null,nick:"From 3"},{id:"to-3",type:"color",def:"#000000ff",blurb:null,nick:"To 3"},{id:"weight-3",type:"number",def:100,blurb:null,nick:"weight 3"},{id:"from-4",type:"color",def:"#000000ff",blurb:null,nick:"From 4"},{id:"to-4",type:"color",def:"#000000ff",blurb:null,nick:"To 4"},{id:"weight-4",type:"number",def:100,blurb:null,nick:"weight 4"},{id:"from-5",type:"color",def:"#000000ff",blurb:null,nick:"From 5"},{id:"to-5",type:"color",def:"#000000ff",blurb:null,nick:"To 5"},{id:"weight-5",type:"number",def:100,blurb:null,nick:"weight 5"},{id:"from-6",type:"color",def:"#000000ff",blurb:null,nick:"From 6"},{id:"to-6",type:"color",def:"#000000ff",blurb:null,nick:"To 6"},{id:"weight-6",type:"number",def:100,blurb:null,nick:"weight 6"},{id:"from-7",type:"color",def:"#000000ff",blurb:null,nick:"From 7"},{id:"to-7",type:"color",def:"#000000ff",blurb:null,nick:"To 7"},{id:"weight-7",type:"number",def:100,blurb:null,nick:"weight 7"},{id:"weight",type:"number",def:1,blurb:null,nick:"global weight scale"},{id:"amount",type:"number",def:1,blurb:null,nick:"amount"}]},{name:"gegl:component-extract",title:"Extract Component",description:"Extract a color model component",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"component",type:"enum",elements:[{label:"RGB Red",value:"rgb-r"},{label:"RGB Green",value:"rgb-g"},{label:"RGB Blue",value:"rgb-b"},{label:"Hue",value:"hue"},{label:"HSV Saturation",value:"hsv-s"},{label:"HSV Value",value:"hsv-v"},{label:"HSL Saturation",value:"hsl-s"},{label:"HSL Lightness",value:"hsl-l"},{label:"CMYK Cyan",value:"cmyk-c"},{label:"CMYK Magenta",value:"cmyk-m"},{label:"CMYK Yellow",value:"cmyk-y"},{label:"CMYK Key",value:"cmyk-k"},{label:"Y'CbCr Y'",value:"ycbcr-y"},{label:"Y'CbCr Cb",value:"ycbcr-cb"},{label:"Y'CbCr Cr",value:"ycbcr-cr"},{label:"LAB L",value:"lab-l"},{label:"LAB A",value:"lab-a"},{label:"LAB B",value:"lab-b"},{label:"LCH C(ab)",value:"lch-c"},{label:"LCH H(ab)",value:"lch-h"}],def:"rgb-r",blurb:"Component to extract",nick:"Component"},{id:"invert",type:"boolean",def:!1,blurb:"Invert the extracted component",nick:"Invert component"},{id:"linear",type:"boolean",def:!1,blurb:"Use linear output instead of gamma corrected",nick:"Linear output"}]},{name:"gegl:contrast-curve",title:"Contrast Curve",description:"Adjusts the contrast of a grayscale image with a curve specifying contrast for intensity.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"sampling-points",type:"int",range:{min:0,max:65536},def:0,blurb:"Number of curve sampling points.  0 for exact calculation.",nick:"Sample points"},{id:"curve",type:"GeglCurve",def:0,blurb:"The contrast curve.",nick:"Curve"}]},{name:"gegl:convert-format",title:"Convert Format",description:"Convert the data to the specified format",categories:"core:color",inputs:["input"],outputs:["output"],properties:[{id:"format",type:"gpointer",def:0,blurb:"The babl format of the output",nick:"Output format"}]},{name:"gegl:convolution-matrix",title:"Convolution Matrix",description:"Apply a generic 5x5 convolution matrix",categories:"generic",inputs:["input"],outputs:["output"],properties:[{id:"a1",type:"number",def:0,blurb:null,nick:"(1,1)"},{id:"a2",type:"number",def:0,blurb:null,nick:"(1,2)"},{id:"a3",type:"number",def:0,blurb:null,nick:"(1,3)"},{id:"a4",type:"number",def:0,blurb:null,nick:"(1,4)"},{id:"a5",type:"number",def:0,blurb:null,nick:"(1,5)"},{id:"b1",type:"number",def:0,blurb:null,nick:"(2,1)"},{id:"b2",type:"number",def:0,blurb:null,nick:"(2,2)"},{id:"b3",type:"number",def:0,blurb:null,nick:"(2,3)"},{id:"b4",type:"number",def:0,blurb:null,nick:"(2,4)"},{id:"b5",type:"number",def:0,blurb:null,nick:"(2,5)"},{id:"c1",type:"number",def:0,blurb:null,nick:"(3,1)"},{id:"c2",type:"number",def:0,blurb:null,nick:"(3,2)"},{id:"c3",type:"number",def:1,blurb:null,nick:"(3,3)"},{id:"c4",type:"number",def:0,blurb:null,nick:"(3,4)"},{id:"c5",type:"number",def:0,blurb:null,nick:"(3,5)"},{id:"d1",type:"number",def:0,blurb:null,nick:"(4,1)"},{id:"d2",type:"number",def:0,blurb:null,nick:"(4,2)"},{id:"d3",type:"number",def:0,blurb:null,nick:"(4,3)"},{id:"d4",type:"number",def:0,blurb:null,nick:"(4,4)"},{id:"d5",type:"number",def:0,blurb:null,nick:"(4,5)"},{id:"e1",type:"number",def:0,blurb:null,nick:"(5,1)"},{id:"e2",type:"number",def:0,blurb:null,nick:"(5,2)"},{id:"e3",type:"number",def:0,blurb:null,nick:"(5,3)"},{id:"e4",type:"number",def:0,blurb:null,nick:"(5,4)"},{id:"e5",type:"number",def:0,blurb:null,nick:"(5,5)"},{id:"divisor",type:"number",def:1,blurb:null,nick:"Divisor"},{id:"offset",type:"number",range:{min:-1,max:1},def:0,blurb:null,nick:"Offset"},{id:"red",type:"boolean",def:!0,blurb:null,nick:"Red channel"},{id:"green",type:"boolean",def:!0,blurb:null,nick:"Green channel"},{id:"blue",type:"boolean",def:!0,blurb:null,nick:"Blue channel"},{id:"alpha",type:"boolean",def:!0,blurb:null,nick:"Alpha channel"},{id:"normalize",type:"boolean",def:!0,blurb:null,nick:"Normalize"},{id:"alpha-weight",type:"boolean",def:!0,blurb:null,nick:"Alpha-weighting"},{id:"border",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"clamp",blurb:null,nick:"Border"}]},{name:"gegl:copy-buffer",title:"Copy Buffer",description:"Writes image data to an already existing buffer",categories:"programming",inputs:["input"],outputs:["output"],properties:[{id:"buffer",type:"GeglBuffer",def:"clamp",blurb:"An already existing GeglBuffer to write incoming buffer data to, or NULL.",nick:"Buffer"}]},{name:"gegl:crop",title:"Crop",description:"Crops a buffer, if the aux pad is connected the bounding box of the node connected is used.",categories:"core",inputs:["aux","input"],outputs:["output"],properties:[{id:"x",type:"number",def:0,blurb:null,nick:"X"},{id:"y",type:"number",def:0,blurb:null,nick:"Y"},{id:"width",type:"number",def:10,blurb:null,nick:"Width"},{id:"height",type:"number",def:10,blurb:null,nick:"Height"},{id:"reset-origin",type:"boolean",def:!1,blurb:null,nick:"Reset origin"}]},{name:"gegl:cubism",title:"Cubism",description:"Convert the image into randomly rotated square blobs, somehow resembling a cubist painting style",categories:"artistic:scramble",inputs:["input"],outputs:["output"],properties:[{id:"tile-size",type:"number",range:{min:0,max:256},def:10,blurb:"Average diameter of each tile (in pixels)",nick:"Tile size"},{id:"tile-saturation",type:"number",range:{min:0,max:10},def:2.5,blurb:"Expand tiles by this amount",nick:"Tile saturation"},{id:"bg-color",type:"color",def:"#00000000",blurb:"The tiles' background color",nick:"Background color"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:deinterlace",title:"Deinterlace",description:"Fix images where every other row or column is missing",categories:"enhance",inputs:["input"],outputs:["output"],properties:[{id:"keep",type:"enum",elements:[{label:"Keep even fields",value:"even"}],def:"even",blurb:"Keep even or odd fields",nick:"Keep"},{id:"orientation",type:"enum",elements:[{label:"Horizontal",value:"horizontal"}],def:"horizontal",blurb:"Deinterlace horizontally or vertically",nick:"Orientation"},{id:"size",type:"int",range:{min:0,max:100},def:1,blurb:"Block size of deinterlacing rows/columns",nick:"Block size"}]},{name:"gegl:difference-of-gaussians",title:"Difference of Gaussians",description:"Edge detection with control of edge thickness, based on the difference of two gaussian blurs",categories:"edge-detect",inputs:["input"],outputs:["output"],properties:[{id:"radius1",type:"number",range:{min:0,max:1e3},def:1,blurb:null,nick:"Radius 1"},{id:"radius2",type:"number",range:{min:0,max:1e3},def:2,blurb:null,nick:"Radius 2"}]},{name:"gegl:diffraction-patterns",title:"Diffraction Patterns",description:"Generate diffraction patterns",categories:"render",inputs:[],outputs:["output"],properties:[{id:"red-frequency",type:"number",range:{min:0,max:20},def:.81,blurb:"Light frequency (red)",nick:"Red frequency"},{id:"green-frequency",type:"number",range:{min:0,max:20},def:1.22,blurb:"Light frequency (green)",nick:"Green frequency"},{id:"blue-frequency",type:"number",range:{min:0,max:20},def:1.12,blurb:"Light frequency (blue)",nick:"Blue frequency"},{id:"red-contours",type:"number",range:{min:0,max:10},def:.82,blurb:"Number of contours (red)",nick:"Red contours"},{id:"green-contours",type:"number",range:{min:0,max:10},def:.82,blurb:"Number of contours (green)",nick:"Green contours"},{id:"blue-contours",type:"number",range:{min:0,max:10},def:.97,blurb:"Number of contours (blue)",nick:"Blue contours"},{id:"red-sedges",type:"number",range:{min:0,max:1},def:.61,blurb:"Number of sharp edges (red)",nick:"Red sharp edges"},{id:"green-sedges",type:"number",range:{min:0,max:1},def:.68,blurb:"Number of sharp edges (green)",nick:"Green sharp edges"},{id:"blue-sedges",type:"number",range:{min:0,max:1},def:.64,blurb:"Number of sharp edges (blue)",nick:"Blue sharp edges"},{id:"brightness",type:"number",range:{min:0,max:1},def:.07,blurb:"Brightness and shifting/fattening of contours",nick:"Brightness"},{id:"scattering",type:"number",range:{min:0,max:100},def:37.13,blurb:"Scattering (speed vs. quality)",nick:"Scattering"},{id:"polarization",type:"number",range:{min:-1,max:1},def:-.47,blurb:"Polarization",nick:"Polarization"},{id:"width",type:"int",range:{min:0},def:200,blurb:"Width of the generated buffer",nick:"Width"},{id:"height",type:"int",range:{min:0},def:200,blurb:"Height of the generated buffer",nick:"Height"}]},{name:"gegl:displace",title:"Displace",description:"Displace pixels as indicated by displacement maps",categories:"map",inputs:["aux2","aux","input"],outputs:["output"],properties:[{id:"displace-mode",type:"enum",elements:[{label:"Cartesian",value:"cartesian"}],def:"cartesian",blurb:"Mode of displacement",nick:"Displacement mode"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"cubic",blurb:"Type of GeglSampler used to fetch input pixels",nick:"Sampler"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"clamp",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"amount-x",type:"number",range:{min:-500,max:500},def:0,blurb:"Displace multiplier for X or radial direction",nick:"X displacement"},{id:"amount-y",type:"number",range:{min:-500,max:500},def:0,blurb:"Displace multiplier for Y or tangent (degrees) direction",nick:"Y displacement"},{id:"center",type:"boolean",def:!1,blurb:"Center the displacement around a specified point",nick:"Center displacement"},{id:"center-x",type:"number",def:.5,blurb:"X coordinate of the displacement center",nick:"Center X"},{id:"center-y",type:"number",def:.5,blurb:"Y coordinate of the displacement center",nick:"Center Y"}]},{name:"gegl:display",title:"Display",description:"Display the input buffer in a window.",categories:"meta:display",inputs:["input"],outputs:[],properties:[{id:"window-title",type:"string",def:"window_title",blurb:"Title to be given to output window",nick:"Window title"}]},{name:"gegl:distance-transform",title:"Distance Transform",description:"Calculate a distance transform",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"metric",type:"enum",elements:[{label:"Euclidean",value:"euclidean"},{label:"Manhattan",value:"manhattan"}],def:"euclidean",blurb:"Metric to use for the distance calculation",nick:"Metric"},{id:"threshold-lo",type:"number",range:{min:0,max:1},def:0,blurb:null,nick:"Threshold low"},{id:"threshold-hi",type:"number",range:{min:0,max:1},def:1,blurb:null,nick:"Threshold high"},{id:"averaging",type:"int",range:{min:0,max:1e3},def:0,blurb:"Number of computations for grayscale averaging",nick:"Grayscale Averaging"},{id:"normalize",type:"boolean",def:!0,blurb:"Normalize output to range 0.0 to 1.0.",nick:"Normalize"}]},{name:"gegl:dither",title:"Dither",description:"Reduce the number of colors in the image, by reducing the levels per channel (colors and alpha). Different dithering methods can be specified to counteract quantization induced banding.",categories:"dither",inputs:["input"],outputs:["output"],properties:[{id:"red-levels",type:"int",range:{min:2,max:65536},def:6,blurb:"Number of levels for red channel",nick:"Red levels"},{id:"green-levels",type:"int",range:{min:2,max:65536},def:7,blurb:"Number of levels for green channel",nick:"Green levels"},{id:"blue-levels",type:"int",range:{min:2,max:65536},def:6,blurb:"Number of levels for blue channel",nick:"Blue levels"},{id:"alpha-levels",type:"int",range:{min:2,max:65536},def:256,blurb:"Number of levels for alpha channel",nick:"Alpha levels"},{id:"dither-method",type:"enum",elements:[{label:"None",value:"none"},{label:"Floyd-Steinberg",value:"floyd-steinberg"},{label:"Bayer",value:"bayer"},{label:"Random",value:"random"},{label:"Random Covariant",value:"random-covariant"},{label:"Arithmetic add",value:"add"},{label:"Arithmetic add covariant",value:"add-covariant"},{label:"Arithmetic xor",value:"xor"}],def:"floyd-steinberg",blurb:"The dithering method to use",nick:"Dithering method"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:divide",title:"Divide",description:"Math operation divide, performs the operation per pixel, using either the constant provided in 'value' or the corresponding pixel from the buffer on aux as operands. The result is the evaluation of the expression result = value==0.0f?0.0f:input/value",categories:"compositors:math",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",def:1,blurb:"global value used if aux doesn't contain data",nick:"Value"}]},{name:"gegl:domain-transform",title:"Smooth by Domain Transform",description:"An edge-preserving smoothing filter implemented with the Domain Transform recursive technique. Similar to a bilateral filter, but faster to compute.",categories:"enhance:noise-reduction",inputs:["input"],outputs:["output"],properties:[{id:"n-iterations",type:"int",range:{min:1,max:5},def:3,blurb:"Number of filtering iterations. A value between 2 and 4 is usually enough.",nick:"Quality"},{id:"spatial-factor",type:"number",range:{min:0,max:1e3},def:30,blurb:"Spatial standard deviation of the blur kernel, measured in pixels.",nick:"Blur radius"},{id:"edge-preservation",type:"number",range:{min:0,max:1},def:.8,blurb:"Amount of edge preservation. This quantity is inversely proportional to the range standard deviation of the blur kernel.",nick:"Edge preservation"}]},{name:"gegl:dropshadow",title:"Dropshadow",description:"Creates a dropshadow effect on the input buffer",categories:"light",inputs:["input"],outputs:["output"],properties:[{id:"x",type:"number",def:20,blurb:"Horizontal shadow offset",nick:"X"},{id:"y",type:"number",def:20,blurb:"Vertical shadow offset",nick:"Y"},{id:"radius",type:"number",range:{min:0},def:10,blurb:null,nick:"Blur radius"},{id:"color",type:"color",def:"#000000ff",blurb:"The shadow's color (defaults to 'black')",nick:"Color"},{id:"opacity",type:"number",range:{min:0,max:2},def:.5,blurb:null,nick:"Opacity"}]},{name:"gegl:edge",title:"Edge Detection",description:"Several simple methods for detecting edges",categories:"edge-detect",inputs:["input"],outputs:["output"],properties:[{id:"algorithm",type:"enum",elements:[{label:"Sobel",value:"sobel"},{label:"Prewitt compass",value:"prewitt"},{label:"Gradient",value:"gradient"},{label:"Roberts",value:"roberts"},{label:"Differential",value:"differential"}],def:"sobel",blurb:"Edge detection algorithm",nick:"Algorithm"},{id:"amount",type:"number",range:{min:1,max:10},def:2,blurb:"Edge detection amount",nick:"Amount"},{id:"border-behavior",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"clamp",blurb:"Edge detection behavior",nick:"Border behavior"}]},{name:"gegl:edge-laplace",title:"Laplacian Edge Detection",description:"High-resolution edge detection",categories:"edge-detect",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:edge-neon",title:"Neon Edge Detection",description:"Performs edge detection using a Gaussian derivative method",categories:"edge-detect",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"number",range:{min:0,max:1500},def:5,blurb:"Radius of effect (in pixels)",nick:"Radius"},{id:"amount",type:"number",range:{min:0,max:100},def:0,blurb:"Strength of Effect",nick:"Intensity"}]},{name:"gegl:edge-sobel",title:"Sobel Edge Detection",description:"Specialized direction-dependent edge detection",categories:"edge-detect",inputs:["input"],outputs:["output"],properties:[{id:"horizontal",type:"boolean",def:!0,blurb:null,nick:"Horizontal"},{id:"vertical",type:"boolean",def:!0,blurb:null,nick:"Vertical"},{id:"keep-sign",type:"boolean",def:!0,blurb:"Keep negative values in result; when off, the absolute value of the result is used instead.",nick:"Keep Sign"}]},{name:"gegl:emboss",title:"Emboss",description:"Simulates an image created by embossing",categories:"light",inputs:["input"],outputs:["output"],properties:[{id:"type",type:"enum",elements:[{label:"Emboss",value:"emboss"}],def:"emboss",blurb:"Rendering type",nick:"Emboss Type"},{id:"azimuth",type:"number",range:{min:0,max:360},def:30,blurb:"Light angle (degrees)",nick:"Azimuth"},{id:"elevation",type:"number",range:{min:0,max:180},def:45,blurb:"Elevation angle (degrees)",nick:"Elevation"},{id:"depth",type:"int",range:{min:1,max:100},def:20,blurb:"Filter width",nick:"Depth"}]},{name:"gegl:engrave",title:"Engrave",description:"Simulate an antique engraving",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"row-height",type:"int",range:{min:2,max:16},def:10,blurb:"Resolution in pixels",nick:"Height"},{id:"limit",type:"boolean",def:!1,blurb:"Limit line width",nick:"Limit line width"}]},{name:"gegl:exp-combine",title:"Combine Exposures",description:"Combine multiple scene exposures into one high dynamic range image.",categories:"compositors",inputs:["exposure-99","exposure-98","exposure-97","exposure-96","exposure-95","exposure-94","exposure-93","exposure-92","exposure-91","exposure-90","exposure-89","exposure-88","exposure-87","exposure-86","exposure-85","exposure-84","exposure-83","exposure-82","exposure-81","exposure-80","exposure-79","exposure-78","exposure-77","exposure-76","exposure-75","exposure-74","exposure-73","exposure-72","exposure-71","exposure-70","exposure-69","exposure-68","exposure-67","exposure-66","exposure-65","exposure-64","exposure-63","exposure-62","exposure-61","exposure-60","exposure-59","exposure-58","exposure-57","exposure-56","exposure-55","exposure-54","exposure-53","exposure-52","exposure-51","exposure-50","exposure-49","exposure-48","exposure-47","exposure-46","exposure-45","exposure-44","exposure-43","exposure-42","exposure-41","exposure-40","exposure-39","exposure-38","exposure-37","exposure-36","exposure-35","exposure-34","exposure-33","exposure-32","exposure-31","exposure-30","exposure-29","exposure-28","exposure-27","exposure-26","exposure-25","exposure-24","exposure-23","exposure-22","exposure-21","exposure-20","exposure-19","exposure-18","exposure-17","exposure-16","exposure-15","exposure-14","exposure-13","exposure-12","exposure-11","exposure-10","exposure-9","exposure-8","exposure-7","exposure-6","exposure-5","exposure-4","exposure-3","exposure-2","exposure-1","exposure-0"],outputs:["output"],properties:[{id:"exposures",type:"string",def:"",blurb:"Relative brightness of each exposure in EV",nick:"Exposure values"},{id:"steps",type:"int",range:{min:8,max:32},def:13,blurb:"Log2 of source's discretization steps",nick:"Discretization bits"},{id:"sigma",type:"number",range:{min:0,max:32},def:8,blurb:"Weight distribution sigma controlling response contributions",nick:"Weight sigma"}]},{name:"gegl:exposure",title:"Exposure",description:"Change exposure of an image in shutter speed stops",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"black-level",type:"number",range:{min:-.1,max:.1},def:0,blurb:"Adjust the black level",nick:"Black level"},{id:"exposure",type:"number",def:0,blurb:"Relative brightness change in stops",nick:"Exposure"}]},{name:"gegl:exr-load",title:null,description:"EXR image loader.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load.",nick:"File"}]},{name:"gegl:exr-save",title:null,description:"OpenEXR image saver",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"path of file to write to.",nick:"File"},{id:"tile",type:"int",range:{min:0,max:2048},def:0,blurb:"tile size to use.",nick:"Tile"}]},{name:"gegl:fattal02",title:"Fattal et al. 2002 Tone Mapping",description:"Adapt an image, which may have a high dynamic range, for presentation using a low dynamic range. This operator attenuates the magnitudes of local image gradients, producing luminance within the range 0.0-1.0. This tonemapping approach was originally presented by Raanan Fattal, in the 2002 SIGGRAPH paper: Gradient Domain High Dynamic Range Compression.",categories:"tonemapping:enhance",inputs:["input"],outputs:["output"],properties:[{id:"alpha",type:"number",range:{min:0,max:2},def:1,blurb:"Gradient threshold for detail enhancement",nick:"Alpha"},{id:"beta",type:"number",range:{min:.1,max:2},def:.9,blurb:"Strength of local detail enhancement",nick:"Beta"},{id:"saturation",type:"number",range:{min:0,max:1},def:.8,blurb:"Global color saturation factor",nick:"Saturation"},{id:"noise",type:"number",range:{min:0,max:1},def:0,blurb:"Gradient threshold for lowering detail enhancement",nick:"Noise"}]},{name:"gegl:ff-load",title:"FFmpeg Frame Loader",description:"FFmpeg video frame importer.",categories:"input:video",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of video file to load",nick:"File"},{id:"frame",type:"int",range:{min:0},def:0,blurb:null,nick:"Frame number"},{id:"frames",type:"int",range:{min:0},def:0,blurb:"Number of frames in video, updates at least when first frame has been decoded.",nick:"frames"},{id:"audio-sample-rate",type:"int",def:0,blurb:null,nick:"audio_sample_rate"},{id:"audio-channels",type:"int",def:0,blurb:null,nick:"audio_channels"},{id:"frame-rate",type:"number",range:{min:0,max:2147483647},def:0,blurb:"Frames per second, permits computing time vs frame",nick:"frame-rate"},{id:"video-codec",type:"string",def:"",blurb:null,nick:"video-codec"},{id:"audio-codec",type:"string",def:"",blurb:null,nick:"audio-codec"},{id:"audio",type:"GeglAudioFragment",def:"",blurb:null,nick:"audio"}]},{name:"gegl:ff-save",title:"FFmpeg Frame Saver",description:"FFmpeg video output sink",categories:"output:video",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"/tmp/fnord.ogv",blurb:"Target path and filename, use '-' for stdout.",nick:"File"},{id:"audio",type:"GeglAudioFragment",def:"/tmp/fnord.ogv",blurb:null,nick:"audio"},{id:"audio-codec",type:"string",def:"auto",blurb:"Audio codec to use, or auto to use a good default based on container format.",nick:"Audio codec"},{id:"audio-sample-rate",type:"int",def:-1,blurb:"-1 means autodetect on first audio fragment",nick:"audio sample rate"},{id:"audio-bit-rate",type:"int",def:64,blurb:"Target encoded video bitrate in kb/s",nick:"audio bitrate in kb/s"},{id:"frame-rate",type:"number",range:{min:0,max:100},def:25,blurb:null,nick:"Frames/second"},{id:"video-codec",type:"string",def:"auto",blurb:"Video codec to use, or auto to use a good default based on container format.",nick:"Video codec"},{id:"video-bit-rate",type:"int",def:128,blurb:"Target encoded video bitrate in kb/s",nick:"video bitrate in kb/s"},{id:"video-bufsize",type:"int",def:0,blurb:null,nick:"Video bufsize"},{id:"container-format",type:"string",def:"auto",blurb:"Container format to use, or auto to autodetect based on file extension.",nick:"Container format"}]},{name:"gegl:fill-path",title:"Fill Path",description:"Renders a filled region",categories:"render:vector",inputs:["input"],outputs:["output"],properties:[{id:"color",type:"color",def:"#000000ff",blurb:"Color of paint to use for filling.",nick:"Color"},{id:"opacity",type:"number",range:{min:-2,max:2},def:1,blurb:"The fill opacity to use.",nick:"Opacity"},{id:"fill-rule",type:"string",def:"nonzero",blurb:"how to determine what to fill (nonzero|evenodd)",nick:"Fill rule."},{id:"transform",type:"string",def:"",blurb:"svg style description of transform.",nick:"Transform"},{id:"d",type:"GeglPath",def:"",blurb:"A GeglVector representing the path of the stroke",nick:"Vector"}]},{name:"gegl:fractal-explorer",title:"Fractal Explorer",description:"Rendering of multiple different fractal systems, with configurable coloring options.",categories:"render:fractal",inputs:[],outputs:["output"],properties:[{id:"fractaltype",type:"enum",elements:[{label:"Mandelbrot",value:"mandelbrot"},{label:"Julia",value:"julia"},{label:"Barnsley 1",value:"barnsley-1"},{label:"Barnsley 2",value:"barnsley-2"},{label:"Barnsley 3",value:"barnsley-3"},{label:"Spider",value:"spider"},{label:"Man O War",value:"man-o-war"},{label:"Lambda",value:"lambda"}],def:"mandelbrot",blurb:"Type of a fractal",nick:"Fractal type"},{id:"iter",type:"int",range:{min:1,max:1e3},def:50,blurb:null,nick:"Iterations"},{id:"zoom",type:"number",range:{min:0,max:1e7},def:300,blurb:"Zoom in the fractal space",nick:"Zoom"},{id:"shiftx",type:"number",def:0,blurb:"X shift in the fractal space",nick:"Shift X"},{id:"shifty",type:"number",def:0,blurb:"Y shift in the fractal space",nick:"Shift Y"},{id:"cx",type:"number",range:{min:-2.5,max:2.5},def:-.75,blurb:"CX (No effect in Mandelbrot and Sierpinski)",nick:"CX"},{id:"cy",type:"number",range:{min:-2.5,max:2.5},def:-.2,blurb:"CY (No effect in Mandelbrot and Sierpinski)",nick:"CY"},{id:"redstretch",type:"number",range:{min:0,max:1},def:1,blurb:null,nick:"Red stretching factor"},{id:"greenstretch",type:"number",range:{min:0,max:1},def:1,blurb:null,nick:"Green stretching factor"},{id:"bluestretch",type:"number",range:{min:0,max:1},def:1,blurb:null,nick:"Blue stretching factor"},{id:"redmode",type:"enum",elements:[{label:"Sine",value:"sine"},{label:"Cosine",value:"cosine"}],def:"cosine",blurb:null,nick:"Red application mode"},{id:"greenmode",type:"enum",elements:[{label:"Sine",value:"sine"},{label:"Cosine",value:"cosine"}],def:"cosine",blurb:null,nick:"Green application mode"},{id:"bluemode",type:"enum",elements:[{label:"Sine",value:"sine"},{label:"Cosine",value:"cosine"}],def:"sine",blurb:null,nick:"Blue application mode"},{id:"redinvert",type:"boolean",def:!1,blurb:null,nick:"Red inversion"},{id:"greeninvert",type:"boolean",def:!1,blurb:null,nick:"Green inversion"},{id:"blueinvert",type:"boolean",def:!1,blurb:null,nick:"Blue inversion"},{id:"ncolors",type:"int",range:{min:2,max:8192},def:256,blurb:null,nick:"Number of colors"},{id:"useloglog",type:"boolean",def:!1,blurb:null,nick:"Loglog smoothing"}]},{name:"gegl:fractal-trace",title:"Fractal Trace",description:"Transform the image with the fractals",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"fractal",type:"enum",elements:[{label:"Mandelbrot",value:"mandelbrot"}],def:"mandelbrot",blurb:null,nick:"Fractal type"},{id:"X1",type:"number",range:{min:-50,max:50},def:-1,blurb:"X1 value, position",nick:"X1"},{id:"X2",type:"number",range:{min:-50,max:50},def:.5,blurb:"X2 value, position",nick:"X2"},{id:"Y1",type:"number",range:{min:-50,max:50},def:-1,blurb:"Y1 value, position",nick:"Y1"},{id:"Y2",type:"number",range:{min:-50,max:50},def:1,blurb:"Y2 value, position",nick:"Y2"},{id:"JX",type:"number",range:{min:-50,max:50},def:.5,blurb:"Julia seed X value, position",nick:"JX"},{id:"JY",type:"number",range:{min:-50,max:50},def:.5,blurb:"Julia seed Y value, position",nick:"JY"},{id:"depth",type:"int",range:{min:1,max:65536},def:3,blurb:null,nick:"Depth"},{id:"bailout",type:"number",range:{min:0},def:1e4,blurb:null,nick:"Bailout length"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"loop",blurb:"How to deal with pixels outside of the input buffer",nick:"Abyss policy"}]},{name:"gegl:gamma",title:"Gamma",description:"Math operation gamma, performs the operation per pixel, using either the constant provided in 'value' or the corresponding pixel from the buffer on aux as operands. The result is the evaluation of the expression result = (input >= 0.0f ? powf (input, value) : -powf (-input, value))",categories:"compositors:math",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",def:1,blurb:"global value used if aux doesn't contain data",nick:"Value"}]},{name:"gegl:gaussian-blur",title:"Gaussian Blur",description:"Performs an averaging of neighboring pixels with the normal distribution as weighting",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"std-dev-x",type:"number",range:{min:0,max:1500},def:1.5,blurb:"Standard deviation for the horizontal axis",nick:"Size X"},{id:"std-dev-y",type:"number",range:{min:0,max:1500},def:1.5,blurb:"Standard deviation (spatial scale factor)",nick:"Size Y"},{id:"filter",type:"enum",elements:[{label:"Auto",value:"auto"},{label:"FIR",value:"fir"}],def:"auto",blurb:"How the gaussian kernel is discretized",nick:"Filter"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Black",value:"black"}],def:"clamp",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"clip-extent",type:"boolean",def:!0,blurb:"Should the output extent be clipped to the input extent",nick:"Clip to the input extent"}]},{name:"gegl:gaussian-blur-selective",title:"Selective Gaussian Blur",description:"Blur neighboring pixels, but only in low-contrast areas",categories:"enhance:noise-reduction",inputs:["aux","input"],outputs:["output"],properties:[{id:"blur-radius",type:"number",range:{min:1,max:1e3},def:5,blurb:"Radius of square pixel region, (width and height will be radius*2+1).",nick:"Blur radius"},{id:"max-delta",type:"number",range:{min:0,max:1},def:.2,blurb:"Maximum delta",nick:"Max. delta"}]},{name:"gegl:gblur-1d",title:"1D Gaussian-blur",description:"Performs an averaging of neighboring pixels with the normal distribution as weighting",categories:"hidden:blur",inputs:["input"],outputs:["output"],properties:[{id:"std-dev",type:"number",range:{min:0,max:1500},def:1.5,blurb:"Standard deviation (spatial scale factor)",nick:"Size"},{id:"orientation",type:"enum",elements:[{label:"Horizontal",value:"horizontal"}],def:"horizontal",blurb:"The orientation of the blur - hor/ver",nick:"Orientation"},{id:"filter",type:"enum",elements:[{label:"Auto",value:"auto"},{label:"FIR",value:"fir"}],def:"auto",blurb:"How the gaussian kernel is discretized",nick:"Filter"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Black",value:"black"}],def:"none",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"clip-extent",type:"boolean",def:!0,blurb:"Should the output extent be clipped to the input extent",nick:"Clip to the input extent"}]},{name:"gegl:gegl",title:"GEGL graph",description:"Do a chain of operations, with key=value pairs after each operation name to set properties. And aux=[ source filter ] for specifying a chain with a source as something connected to an aux pad.",categories:"generic",inputs:["input"],outputs:["output"],properties:[{id:"string",type:"string",def:"gaussian-blur std-dev-x=0.3rel std-dev-y=0.3rel",blurb:"[op [property=value] [property=value]] [[op] [property=value]",nick:"pipeline"},{id:"error",type:"string",def:"",blurb:"There is a problem in the syntax or in the application of parsed property values. Things might mostly work nevertheless.",nick:"Eeeeeek"}]},{name:"gegl:gegl-buffer-load",title:null,description:"GeglBuffer file loader.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"/tmp/gegl-buffer.gegl",blurb:"Path of GeglBuffer file to load.",nick:"File"}]},{name:"gegl:gegl-buffer-save",title:null,description:"GeglBuffer file writer.",categories:"hidden",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"/tmp/gegl-buffer.gegl",blurb:"Target file path to write GeglBuffer to.",nick:"File"}]},{name:"gegl:gif-load",title:"GIF File Loader",description:"GIF image loader.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load",nick:"File"},{id:"frame",type:"int",def:0,blurb:"frame number to decode",nick:"frame"},{id:"frames",type:"int",def:0,blurb:"Number of frames in gif animation",nick:"frames"},{id:"frame-delay",type:"int",def:100,blurb:"Delay in ms for last decoded frame",nick:"frame-delay"}]},{name:"gegl:gray",title:"Make Grey",description:"Turns the image grayscale",categories:"grayscale:color",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:grid",title:"Grid",description:"Grid renderer",categories:"render",inputs:[],outputs:["output"],properties:[{id:"x",type:"int",range:{min:1},def:32,blurb:"Horizontal width of cells pixels",nick:"Width"},{id:"y",type:"int",range:{min:1},def:32,blurb:"Vertical width of cells pixels",nick:"Height"},{id:"x-offset",type:"int",def:0,blurb:"Horizontal offset (from origin) for start of grid",nick:"Offset X"},{id:"y-offset",type:"int",def:0,blurb:"Vertical offset (from origin) for start of grid",nick:"Offset Y"},{id:"line-width",type:"int",range:{min:0},def:4,blurb:"Width of grid lines in pixels",nick:"Line width"},{id:"line-height",type:"int",range:{min:0},def:4,blurb:"Height of grid lines in pixels",nick:"Line height"},{id:"line-color",type:"color",def:"#000000ff",blurb:"Color of the grid lines",nick:"Color"}]},{name:"gegl:high-pass",title:"High Pass Filter",description:"Enhances fine details.",categories:"frequency",inputs:["input"],outputs:["output"],properties:[{id:"std-dev",type:"number",range:{min:0,max:1e4},def:4,blurb:"Standard deviation (spatial scale factor)",nick:"Std. Dev."},{id:"contrast",type:"number",range:{min:0,max:5},def:1,blurb:"Contrast of high-pass",nick:"Contrast"}]},{name:"gegl:hue-chroma",title:"Hue-Chroma",description:"Adjust LCH Hue, Chroma, and Lightness",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"hue",type:"number",range:{min:-180,max:180},def:0,blurb:"Hue adjustment",nick:"Hue"},{id:"chroma",type:"number",range:{min:-100,max:100},def:0,blurb:"Chroma adjustment",nick:"Chroma"},{id:"lightness",type:"number",range:{min:-100,max:100},def:0,blurb:"Lightness adjustment",nick:"Lightness"}]},{name:"gegl:icc-save",title:"ICC profile saver",description:"Stores the ICC profile that would be embedded if stored as an image.",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename",nick:"File"}]},{name:"gegl:illusion",title:"Illusion",description:"Superimpose many altered copies of the image.",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"division",type:"int",range:{min:0,max:64},def:8,blurb:"The number of divisions",nick:"Division"},{id:"illusion-type",type:"enum",elements:[{label:"Type 1",value:"type1"}],def:"type1",blurb:"Type of illusion",nick:"Illusion type"}]},{name:"gegl:image-compare",title:null,description:"Compares if input and aux buffers are different. Global statistics are saved in the properties and a visual difference image is produced as a visual result. ",categories:"programming",inputs:["aux","input"],outputs:["output"],properties:[{id:"wrong-pixels",type:"int",def:0,blurb:"Number of differing pixels.",nick:"Wrong pixels"},{id:"max-diff",type:"number",def:0,blurb:"Maximum difference between two pixels.",nick:"Maximum difference"},{id:"avg-diff-wrong",type:"number",def:0,blurb:"Average difference between wrong pixels.",nick:"Average difference (wrong)"},{id:"avg-diff-total",type:"number",def:0,blurb:"Average difference between all pixels.",nick:"Average difference (total)"}]},{name:"gegl:image-gradient",title:"Image Gradient",description:"Compute gradient magnitude and/or direction by central differencies",categories:"edge-detect",inputs:["input"],outputs:["output"],properties:[{id:"output-mode",type:"enum",elements:[{label:"Magnitude",value:"magnitude"},{label:"Direction",value:"direction"}],def:"magnitude",blurb:"Output Mode",nick:"Output mode"}]},{name:"gegl:introspect",title:null,description:"GEGL graph visualizer.",categories:"render",inputs:[],outputs:["output"],properties:[{id:"node",type:"GeglNode",def:"magnitude",blurb:null,nick:"Node"}]},{name:"gegl:invert-gamma",title:"Invert in Perceptual space",description:'Invert the components (except alpha) perceptually, the result is the corresponding "negative" image.',categories:"color",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:invert-linear",title:"Invert",description:'Invert the components (except alpha) in linear light, the result is the corresponding "negative" image.',categories:"color",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:jpg-load",title:"JPEG File Loader",description:"JPEG image loader using libjpeg",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI of file to load",nick:"URI"}]},{name:"gegl:jpg-save",title:"JPEG File Saver",description:"JPEG image saver, using libjpeg",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout",nick:"File"},{id:"quality",type:"int",range:{min:1,max:100},def:90,blurb:"JPEG compression quality (between 1 and 100)",nick:"Quality"},{id:"smoothing",type:"int",range:{min:0,max:100},def:0,blurb:"Smoothing factor from 1 to 100; 0 disables smoothing",nick:"Smoothing"},{id:"optimize",type:"boolean",def:!0,blurb:"Use optimized huffman tables",nick:"Optimize"},{id:"progressive",type:"boolean",def:!0,blurb:"Create progressive JPEG images",nick:"Progressive"},{id:"grayscale",type:"boolean",def:!1,blurb:"Create a grayscale (monochrome) image",nick:"Grayscale"}]},{name:"gegl:layer",title:"Layer",description:"A layer in the traditional sense",categories:"meta",inputs:["aux","input"],outputs:["output"],properties:[{id:"composite-op",type:"string",def:"gegl:over",blurb:"Composite operation to use",nick:"Operation"},{id:"opacity",type:"number",range:{min:0,max:1},def:1,blurb:null,nick:"Opacity"},{id:"x",type:"number",def:0,blurb:"Horizontal position in pixels",nick:"X"},{id:"y",type:"number",def:0,blurb:"Vertical position in pixels",nick:"Y"},{id:"scale",type:"number",def:1,blurb:"Scale 1:1 size",nick:"Scale"},{id:"src",type:"string",def:"",blurb:"Source image file path (png, jpg, raw, svg, bmp, tif, ...)",nick:"Source"}]},{name:"gegl:lcms-from-profile",title:"LCMS From Profile",description:"Converts the input from an ICC color profile to a well defined babl format. The buffer's data will then be correctly managed by GEGL for further processing.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"src-profile",type:"gpointer",def:"",blurb:null,nick:"Source Profile"},{id:"intent",type:"enum",elements:[{label:"Perceptual",value:"perceptual"},{label:"Relative Colorimetric",value:"relative-colorimetric"},{label:"Saturation",value:"saturation"}],def:"perceptual",blurb:"The rendering intent to use in the conversion.",nick:"Rendering intent"},{id:"black-point-compensation",type:"boolean",def:!1,blurb:"Convert using black point compensation.",nick:"Black point compensation"}]},{name:"gegl:lens-distortion",title:"Lens Distortion",description:"Corrects barrel or pincushion lens distortion.",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"main",type:"number",range:{min:-100,max:100},def:0,blurb:"Amount of second-order distortion",nick:"Main"},{id:"edge",type:"number",range:{min:-100,max:100},def:0,blurb:"Amount of fourth-order distortion",nick:"Edge"},{id:"zoom",type:"number",range:{min:-100,max:100},def:0,blurb:"Rescale overall image size",nick:"Zoom"},{id:"x-shift",type:"number",range:{min:-100,max:100},def:0,blurb:"Effect centre offset in X",nick:"Shift X"},{id:"y-shift",type:"number",range:{min:-100,max:100},def:0,blurb:"Effect centre offset in Y",nick:"Shift Y"},{id:"brighten",type:"number",range:{min:-100,max:100},def:0,blurb:"Adjust brightness in corners",nick:"Brighten"},{id:"background",type:"color",def:"#00000000",blurb:null,nick:"Background color"}]},{name:"gegl:lens-flare",title:"Lens Flare",description:"Adds a lens flare effect.",categories:"light",inputs:["input"],outputs:["output"],properties:[{id:"pos-x",type:"number",def:.5,blurb:"X coordinates of the flare center",nick:"X position"},{id:"pos-y",type:"number",def:.5,blurb:"Y coordinates of the flare center",nick:"Y position"}]},{name:"gegl:levels",title:"Levels",description:"Remaps the intensity range of the image",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"in-low",type:"number",range:{min:-1,max:4},def:0,blurb:"Input luminance level to become lowest output",nick:"Low input"},{id:"in-high",type:"number",range:{min:-1,max:4},def:1,blurb:"Input luminance level to become white",nick:"High input"},{id:"out-low",type:"number",range:{min:-1,max:4},def:0,blurb:"Lowest luminance level in output",nick:"Low output"},{id:"out-high",type:"number",range:{min:-1,max:4},def:1,blurb:"Highest luminance level in output",nick:"High output"}]},{name:"gegl:linear-gradient",title:"Linear Gradient",description:"Linear gradient renderer",categories:"render:gradient",inputs:[],outputs:["output"],properties:[{id:"start-x",type:"number",def:25,blurb:null,nick:"X1"},{id:"start-y",type:"number",def:25,blurb:null,nick:"Y1"},{id:"end-x",type:"number",def:150,blurb:null,nick:"X2"},{id:"end-y",type:"number",def:150,blurb:null,nick:"Y2"},{id:"start-color",type:"color",def:"#000000ff",blurb:"The color at (x1, y1)",nick:"Start Color"},{id:"end-color",type:"color",def:"#ffffffff",blurb:"The color at (x2, y2)",nick:"End Color"}]},{name:"gegl:linear-sinusoid",title:"Linear Sinusoid",description:"Generate a linear sinusoid pattern",categories:"render",inputs:[],outputs:["output"],properties:[{id:"x-period",type:"number",range:{min:0},def:128,blurb:"Period for X axis",nick:"X Period"},{id:"y-period",type:"number",range:{min:0},def:128,blurb:"Period for Y axis",nick:"Y Period"},{id:"x-amplitude",type:"number",def:0,blurb:"Amplitude for X axis (logarithmic scale)",nick:"X Amplitude"},{id:"y-amplitude",type:"number",def:0,blurb:"Amplitude for Y axis (logarithmic scale)",nick:"Y Amplitude"},{id:"x-phase",type:"number",def:0,blurb:"Phase for X axis",nick:"X Phase"},{id:"y-phase",type:"number",def:0,blurb:"Phase for Y axis",nick:"Y Phase"},{id:"angle",type:"number",range:{min:0,max:360},def:90,blurb:"Axis separation angle",nick:"Angle"},{id:"offset",type:"number",def:0,blurb:"Value offset",nick:"Offset"},{id:"exponent",type:"number",def:0,blurb:"Value exponent (logarithmic scale)",nick:"Exponent"},{id:"x-offset",type:"number",def:0,blurb:"Offset for X axis",nick:"X Offset"},{id:"y-offset",type:"number",def:0,blurb:"Offset for Y axis",nick:"Y Offset"},{id:"rotation",type:"number",range:{min:0,max:360},def:0,blurb:"Pattern rotation angle",nick:"Rotation"},{id:"supersampling",type:"int",range:{min:1,max:8},def:1,blurb:"Number of samples along each axis per pixel",nick:"Supersampling"}]},{name:"gegl:load",title:"Load Image",description:"Multipurpose file loader, that uses other native handlers, and fallback conversion using Image Magick's convert.",categories:"meta:input",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load.",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI of file to load.",nick:"URI"}]},{name:"gegl:long-shadow",title:"Long Shadow",description:"Creates a long-shadow effect",categories:"light",inputs:["input"],outputs:["output"],properties:[{id:"style",type:"enum",elements:[{label:"Finite",value:"finite"},{label:"Infinite",value:"infinite"},{label:"Fading",value:"fading"}],def:"finite",blurb:"Shadow style",nick:"Style"},{id:"angle",type:"number",range:{min:-180,max:180},def:45,blurb:"Shadow angle",nick:"Angle"},{id:"length",type:"number",range:{min:0},def:100,blurb:"Shadow length",nick:"Length"},{id:"midpoint",type:"number",range:{min:0},def:100,blurb:"Shadow fade midpoint",nick:"Midpoint"},{id:"midpoint-rel",type:"number",range:{min:0,max:1},def:.5,blurb:"Shadow fade midpoint, as a factor of the shadow length",nick:"Midpoint (relative)"},{id:"color",type:"color",def:"#000000ff",blurb:"Shadow color",nick:"Color"},{id:"composition",type:"enum",elements:[{label:"Shadow plus image",value:"shadow-plus-image"},{label:"Shadow only",value:"shadow-only"}],def:"shadow-plus-image",blurb:"Output composition",nick:"Composition"}]},{name:"gegl:magick-load",title:null,description:"Image Magick wrapper using the png op.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"/tmp/gegl-logo.svg",blurb:"Path of file to load.",nick:"File"}]},{name:"gegl:mantiuk06",title:"Mantiuk 2006 Tone Mapping",description:"Adapt an image, which may have a high dynamic range, for presentation using a low dynamic range. This operator constrains contrasts across multiple spatial frequencies, producing luminance within the range 0.0-1.0",categories:"tonemapping",inputs:["input"],outputs:["output"],properties:[{id:"contrast",type:"number",range:{min:0,max:1},def:.1,blurb:"The amount of contrast compression",nick:"Contrast"},{id:"saturation",type:"number",range:{min:0,max:2},def:.8,blurb:"Global color saturation factor",nick:"Saturation"},{id:"detail",type:"number",range:{min:1,max:99},def:1,blurb:"Level of emphasis on image gradient details",nick:"Detail"}]},{name:"gegl:map-absolute",title:"Map Absolute",description:"sample input with an auxiliary buffer that contain absolute source coordinates",categories:"map",inputs:["aux","input"],outputs:["output"],properties:[{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"cubic",blurb:null,nick:"Resampling method"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"none",blurb:null,nick:"Abyss policy"}]},{name:"gegl:map-relative",title:"Map Relative",description:"sample input with an auxiliary buffer that contain relative source coordinates",categories:"map",inputs:["aux","input"],outputs:["output"],properties:[{id:"scaling",type:"number",range:{min:0,max:5e3},def:1,blurb:"scaling factor of displacement, indicates how large spatial displacement a relative mapping value of 1.0 corresponds to.",nick:"Scaling"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"cubic",blurb:null,nick:"Resampling method"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"none",blurb:null,nick:"Abyss policy"}]},{name:"gegl:matting-global",title:"Matting Global",description:"Given a sparse user supplied tri-map and an input image, create a foreground alpha matte. Set white as foreground, black as background for the tri-map. Everything else will be treated as unknown and filled in.",categories:"matting",inputs:["aux","input"],outputs:["output"],properties:[{id:"iterations",type:"int",range:{min:1,max:1e4},def:10,blurb:null,nick:"Iterations"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:matting-levin",title:"Matting Levin",description:"Given a sparse user supplied tri-map and an input image, create a foreground alpha mat. Set white as selected, black as unselected, for the tri-map.",categories:"matting",inputs:["aux","input"],outputs:["output"],properties:[{id:"epsilon",type:"int",range:{min:-9,max:-1},def:-6,blurb:"Log of the error weighting",nick:"Epsilon"},{id:"radius",type:"int",range:{min:1,max:3},def:1,blurb:"Radius of the processing window",nick:"Radius"},{id:"threshold",type:"number",range:{min:0,max:.1},def:.02,blurb:"Alpha threshold for multilevel processing",nick:"Threshold"},{id:"lambda",type:"number",range:{min:0,max:100},def:100,blurb:"Trimap influence factor",nick:"Lambda"},{id:"levels",type:"int",range:{min:0,max:8},def:4,blurb:"Number of downsampled levels to use",nick:"Levels"},{id:"active-levels",type:"int",range:{min:0,max:8},def:2,blurb:"Number of levels to perform solving",nick:"Active levels"}]},{name:"gegl:maze",title:"Maze",description:"Draw a labyrinth",categories:"render",inputs:["input"],outputs:["output"],properties:[{id:"x",type:"int",range:{min:1},def:16,blurb:"Horizontal width of cells pixels",nick:"Width"},{id:"y",type:"int",range:{min:1},def:16,blurb:"Vertical width of cells pixels",nick:"Height"},{id:"algorithm-type",type:"enum",elements:[{label:"Depth first",value:"depth-first"}],def:"depth-first",blurb:"Maze algorithm type",nick:"Algorithm type"},{id:"tileable",type:"boolean",def:!1,blurb:null,nick:"Tileable"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"},{id:"fg-color",type:"color",def:"#000000ff",blurb:"The foreground color",nick:"Foreground Color"},{id:"bg-color",type:"color",def:"#ffffffff",blurb:"The background color",nick:"Background Color"}]},{name:"gegl:mblur",title:"Temporal blur",description:"Accumulating motion blur using a kalman filter, for use with video sequences of frames.",categories:"blur:video",inputs:["input"],outputs:["output"],properties:[{id:"dampness",type:"number",range:{min:0,max:1},def:.95,blurb:"The value represents the contribution of the past to the new frame.",nick:"Dampness"}]},{name:"gegl:mean-curvature-blur",title:"Mean Curvature Blur",description:"Regularize geometry at a speed proportional to the local mean curvature value",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"iterations",type:"int",range:{min:0,max:500},def:20,blurb:"Controls the number of iterations",nick:"Iterations"}]},{name:"gegl:median-blur",title:"Median Blur",description:"Blur resulting from computing the median color in the neighborhood of each pixel.",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"neighborhood",type:"enum",elements:[{label:"Square",value:"square"},{label:"Circle",value:"circle"}],def:"circle",blurb:"Neighborhood type",nick:"Neighborhood"},{id:"radius",type:"int",range:{min:0,max:100},def:3,blurb:"Neighborhood radius",nick:"Radius"},{id:"percentile",type:"number",range:{min:0,max:100},def:50,blurb:"Neighborhood color percentile",nick:"Percentile"},{id:"alpha-percentile",type:"number",range:{min:0,max:100},def:50,blurb:"Neighborhood alpha percentile",nick:"Alpha percentile"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"}],def:"(null)",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"high-precision",type:"boolean",def:!1,blurb:"Avoid clipping and quantization (slower)",nick:"High precision"}]},{name:"gegl:mirrors",title:"Kaleidoscopic Mirroring",description:"Create a kaleidoscope like effect.",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"m-angle",type:"number",range:{min:0,max:180},def:0,blurb:"Rotation applied to the mirrors",nick:"Mirror rotation"},{id:"r-angle",type:"number",range:{min:0,max:360},def:0,blurb:"Rotation applied to the result",nick:"Result rotation"},{id:"n-segs",type:"int",range:{min:2,max:24},def:6,blurb:"Number of mirrors to use",nick:"Mirrors"},{id:"c-x",type:"number",range:{min:0,max:1},def:.5,blurb:"position of symmetry center in output",nick:"Offset X"},{id:"c-y",type:"number",range:{min:0,max:1},def:.5,blurb:"position of symmetry center in output",nick:"Offset Y"},{id:"o-x",type:"number",range:{min:-1,max:1},def:0,blurb:"X axis ratio for the center of mirroring",nick:"Center X"},{id:"o-y",type:"number",range:{min:-1,max:1},def:0,blurb:"Y axis ratio for the center of mirroring",nick:"Center Y"},{id:"trim-x",type:"number",range:{min:0,max:.5},def:0,blurb:"X axis ratio for trimming mirror expanse",nick:"Trim X"},{id:"trim-y",type:"number",range:{min:0,max:.5},def:0,blurb:"Y axis ratio for trimming mirror expanse",nick:"Trim Y"},{id:"input-scale",type:"number",range:{min:.1,max:100},def:100,blurb:"Scale factor to make rendering size bigger",nick:"Zoom"},{id:"output-scale",type:"number",range:{min:0,max:100},def:1,blurb:"Scale factor to make rendering size bigger",nick:"Expand"},{id:"clip",type:"boolean",def:!0,blurb:null,nick:"Clip result to input size"},{id:"warp",type:"boolean",def:!0,blurb:"Fill full output area",nick:"Wrap input"}]},{name:"gegl:mix",title:"Mix",description:"Do a lerp, linear interpolation (lerp) between input and aux",categories:null,inputs:["aux","input"],outputs:["output"],properties:[{id:"ratio",type:"number",def:.5,blurb:"Mixing ratio, read as amount of aux, 0=input 0.5=half 1.0=aux",nick:"Ratio"}]},{name:"gegl:mono-mixer",title:"Mono Mixer",description:"Monochrome channel mixer",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"preserve-luminosity",type:"boolean",def:!1,blurb:null,nick:"Preserve luminosity"},{id:"red",type:"number",range:{min:-5,max:5},def:.33,blurb:null,nick:"Red Channel Multiplier"},{id:"green",type:"number",range:{min:-5,max:5},def:.33,blurb:null,nick:"Green Channel Multiplier"},{id:"blue",type:"number",range:{min:-5,max:5},def:.33,blurb:null,nick:"Blue Channel Multiplier"}]},{name:"gegl:mosaic",title:"Mosaic",description:"Mosaic is a filter which transforms an image into what appears to be a mosaic, composed of small primitives, each of constant color and of an approximate size.",categories:"artistic:scramble",inputs:["input"],outputs:["output"],properties:[{id:"tile-type",type:"enum",elements:[{label:"Squares",value:"squares"},{label:"Hexagons",value:"hexagons"},{label:"Octagons",value:"octagons"}],def:"hexagons",blurb:"What shape to use for tiles",nick:"Tile geometry"},{id:"tile-size",type:"number",range:{min:1,max:1e3},def:15,blurb:"Average diameter of each tile (in pixels)",nick:"Tile size"},{id:"tile-height",type:"number",range:{min:1,max:1e3},def:4,blurb:"Apparent height of each tile (in pixels)",nick:"Tile height"},{id:"tile-neatness",type:"number",range:{min:0,max:1},def:.65,blurb:"Deviation from perfectly formed tiles",nick:"Tile neatness"},{id:"color-variation",type:"number",range:{min:0,max:1},def:.2,blurb:"Magnitude of random color variations",nick:"Tile color variation"},{id:"color-averaging",type:"boolean",def:!0,blurb:"Tile color based on average of subsumed pixels",nick:"Color averaging"},{id:"tile-surface",type:"boolean",def:!1,blurb:"Surface characteristics",nick:"Rough tile surface"},{id:"tile-allow-split",type:"boolean",def:!0,blurb:"Allows splitting tiles at hard edges",nick:"Allow splitting tiles"},{id:"tile-spacing",type:"number",range:{min:0,max:1e3},def:1,blurb:"Inter-tile spacing (in pixels)",nick:"Tile spacing"},{id:"joints-color",type:"color",def:"#000000ff",blurb:null,nick:"Joints color"},{id:"light-color",type:"color",def:"#ffffffff",blurb:null,nick:"Light color"},{id:"light-dir",type:"number",range:{min:0,max:360},def:135,blurb:"Direction of light-source (in degrees)",nick:"Light direction"},{id:"antialiasing",type:"boolean",def:!0,blurb:"Enables smoother tile output",nick:"Antialiasing"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:motion-blur-circular",title:"Circular Motion Blur",description:"Circular motion blur",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"center-x",type:"number",def:.5,blurb:null,nick:"Center X"},{id:"center-y",type:"number",def:.5,blurb:null,nick:"Center Y"},{id:"angle",type:"number",range:{min:0,max:360},def:5,blurb:"Rotation blur angle. A large angle may take some time to render",nick:"Angle"}]},{name:"gegl:motion-blur-linear",title:"Linear Motion Blur",description:"Blur pixels in a direction, simulates blurring caused by moving camera in a straight line during exposure.",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"length",type:"number",range:{min:0,max:1e3},def:10,blurb:"Length of blur in pixels",nick:"Length"},{id:"angle",type:"number",range:{min:-180,max:180},def:0,blurb:"Angle of blur in degrees",nick:"Angle"}]},{name:"gegl:motion-blur-zoom",title:"Zooming Motion Blur",description:"Zoom motion blur",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"center-x",type:"number",range:{min:-10,max:10},def:.5,blurb:null,nick:"Center X"},{id:"center-y",type:"number",range:{min:-10,max:10},def:.5,blurb:null,nick:"Center Y"},{id:"factor",type:"number",range:{min:-10,max:1},def:.1,blurb:null,nick:"Blurring factor"}]},{name:"gegl:multiply",title:"Multiply",description:"Math operation multiply, performs the operation per pixel, using either the constant provided in 'value' or the corresponding pixel from the buffer on aux as operands. The result is the evaluation of the expression result = input * value",categories:"compositors:math",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",def:1,blurb:"global value used if aux doesn't contain data",nick:"Value"}]},{name:"gegl:newsprint",title:"Newsprint",description:"Digital halftoning with optional modulations. ",categories:"render",inputs:["input"],outputs:["output"],properties:[{id:"color-model",type:"enum",elements:[{label:"White on Black",value:"white-on-black"},{label:"Black on White",value:"black-on-white"},{label:"RGB",value:"rgb"}],def:"black-on-white",blurb:"How many inks to use just black, rg, rgb (additive), or cmyk",nick:"Color Model"},{id:"pattern2",type:"enum",elements:[{label:"Line",value:"line"},{label:"Circle",value:"circle"},{label:"Diamond",value:"diamond"},{label:"PSSquare (or Euclidian) dot",value:"pssquare"}],def:"line",blurb:"Halftoning/dot pattern to use",nick:"Red and cyan pattern"},{id:"period2",type:"number",range:{min:0,max:200},def:12,blurb:"The number of pixels across one repetition of a base pattern at base resolution.",nick:"Red and cyan period"},{id:"angle2",type:"number",range:{min:-180,max:180},def:15,blurb:null,nick:"Red and cyan angle"},{id:"pattern3",type:"enum",elements:[{label:"Line",value:"line"},{label:"Circle",value:"circle"},{label:"Diamond",value:"diamond"},{label:"PSSquare (or Euclidian) dot",value:"pssquare"}],def:"line",blurb:"Halftoning/dot pattern to use",nick:"Green and magenta pattern"},{id:"period3",type:"number",range:{min:0,max:200},def:12,blurb:"The number of pixels across one repetition of a base pattern at base resolution.",nick:"Green and magenta period"},{id:"angle3",type:"number",range:{min:-180,max:180},def:45,blurb:null,nick:"Green and magenta angle"},{id:"pattern4",type:"enum",elements:[{label:"Line",value:"line"},{label:"Circle",value:"circle"},{label:"Diamond",value:"diamond"},{label:"PSSquare (or Euclidian) dot",value:"pssquare"}],def:"line",blurb:"Halftoning/dot pattern to use",nick:"Blue and Yellow pattern"},{id:"period4",type:"number",range:{min:0,max:200},def:12,blurb:"The number of pixels across one repetition of a base pattern at base resolution.",nick:"Blue and Yellow period"},{id:"angle4",type:"number",range:{min:-180,max:180},def:0,blurb:null,nick:"Blue and Yellow angle"},{id:"pattern",type:"enum",elements:[{label:"Line",value:"line"},{label:"Circle",value:"circle"},{label:"Diamond",value:"diamond"},{label:"PSSquare (or Euclidian) dot",value:"pssquare"}],def:"line",blurb:"Halftoning/dot pattern to use",nick:"Black pattern"},{id:"period",type:"number",range:{min:0,max:200},def:12,blurb:"Angle offset for patterns",nick:"Black period"},{id:"angle",type:"number",range:{min:-180,max:180},def:75,blurb:"Angle offset for patterns",nick:"Black angle"},{id:"black-pullout",type:"number",range:{min:0,max:1},def:1,blurb:"How much of common gray to pull out of CMY",nick:"Black pullout"},{id:"aa-samples",type:"int",range:{min:1,max:128},def:16,blurb:"Number of samples that are averaged for antialiasing the result.",nick:"Anti-alias oversampling factor"},{id:"turbulence",type:"number",range:{min:0,max:1},def:0,blurb:"Color saturation dependent compression of period",nick:"Turbulence"},{id:"blocksize",type:"number",range:{min:-1,max:64},def:-1,blurb:"Number of periods per tile, this tiling avoids high frequency anomaly that angle boost causes",nick:"Blocksize"},{id:"angleboost",type:"number",range:{min:0,max:4},def:0,blurb:"Multiplication factor for desired rotation of the local space for texture, the way this is computed makes it weak for desaturated colors and possibly stronger where there is color.",nick:"Angle Boost"}]},{name:"gegl:noise-cie-lch",title:"Add CIE Lch Noise",description:"Randomize lightness, chroma and hue independently",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"holdness",type:"int",range:{min:1,max:8},def:2,blurb:"A high value lowers the randomness of the noise",nick:"Dulling"},{id:"lightness-distance",type:"number",range:{min:0,max:100},def:40,blurb:null,nick:"Lightness"},{id:"chroma-distance",type:"number",range:{min:0,max:100},def:40,blurb:null,nick:"Chroma"},{id:"hue-distance",type:"number",range:{min:0,max:180},def:3,blurb:null,nick:"Hue"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:noise-hsv",title:"Add HSV Noise",description:"Randomize hue, saturation and value independently",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"holdness",type:"int",range:{min:1,max:8},def:2,blurb:"A high value lowers the randomness of the noise",nick:"Dulling"},{id:"hue-distance",type:"number",range:{min:0,max:180},def:3,blurb:null,nick:"Hue"},{id:"saturation-distance",type:"number",range:{min:0,max:1},def:.04,blurb:null,nick:"Saturation"},{id:"value-distance",type:"number",range:{min:0,max:1},def:.04,blurb:null,nick:"Value"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:noise-hurl",title:"Randomly Shuffle Pixels",description:"Completely randomize a fraction of pixels",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"pct-random",type:"number",range:{min:0,max:100},def:50,blurb:null,nick:"Randomization (%)"},{id:"repeat",type:"int",range:{min:1,max:100},def:1,blurb:null,nick:"Repeat"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:noise-pick",title:"Noise Pick",description:"Randomly interchange some pixels with neighbors",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"pct-random",type:"number",range:{min:0,max:100},def:50,blurb:null,nick:"Randomization (%)"},{id:"repeat",type:"int",range:{min:1,max:100},def:1,blurb:null,nick:"Repeat"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:noise-reduction",title:"Noise Reduction",description:"Anisotropic smoothing operation",categories:"enhance:noise-reduction",inputs:["input"],outputs:["output"],properties:[{id:"iterations",type:"int",range:{min:0,max:32},def:4,blurb:"Controls the number of iterations; lower values give less plastic results",nick:"Strength"}]},{name:"gegl:noise-rgb",title:"Add RGB Noise",description:"Distort colors by random amounts",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"correlated",type:"boolean",def:!1,blurb:null,nick:"Correlated noise"},{id:"independent",type:"boolean",def:!0,blurb:"Control amount of noise for each RGB channel separately",nick:"Independent RGB"},{id:"linear",type:"boolean",def:!0,blurb:"Operate on linearized RGB color data",nick:"Linear RGB"},{id:"gaussian",type:"boolean",def:!0,blurb:"Use a gaussian noise distribution, when unticked a linear noise distribution is used instead",nick:"Gaussian distribution"},{id:"red",type:"number",range:{min:0,max:1},def:.2,blurb:null,nick:"Red"},{id:"green",type:"number",range:{min:0,max:1},def:.2,blurb:null,nick:"Green"},{id:"blue",type:"number",range:{min:0,max:1},def:.2,blurb:null,nick:"Blue"},{id:"alpha",type:"number",range:{min:0,max:1},def:0,blurb:null,nick:"Alpha"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:noise-slur",title:"Noise Slur",description:"Randomly slide some pixels downward (similar to melting)",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"pct-random",type:"number",range:{min:0,max:100},def:50,blurb:null,nick:"Randomization (%)"},{id:"repeat",type:"int",range:{min:1,max:100},def:1,blurb:null,nick:"Repeat"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:noise-solid",title:"Solid Noise",description:"Create a random cloud-like texture",categories:"render",inputs:[],outputs:["output"],properties:[{id:"x-size",type:"number",range:{min:.1,max:16},def:4,blurb:"Horizontal texture size",nick:"X Size"},{id:"y-size",type:"number",range:{min:.1,max:16},def:4,blurb:"Vertical texture size",nick:"Y Size"},{id:"detail",type:"int",range:{min:0,max:15},def:1,blurb:"Detail level",nick:"Detail"},{id:"tileable",type:"boolean",def:!1,blurb:"Create a tileable output",nick:"Tileable"},{id:"turbulent",type:"boolean",def:!1,blurb:"Make a turbulent noise",nick:"Turbulent"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"},{id:"width",type:"int",range:{min:0},def:1024,blurb:"Width of the generated buffer",nick:"Width"},{id:"height",type:"int",range:{min:0},def:768,blurb:"Height of the generated buffer",nick:"Height"}]},{name:"gegl:noise-spread",title:"Noise Spread",description:"Move pixels around randomly",categories:"noise",inputs:["input"],outputs:["output"],properties:[{id:"amount-x",type:"int",range:{min:0,max:512},def:5,blurb:"Horizontal spread amount",nick:"Horizontal"},{id:"amount-y",type:"int",range:{min:0,max:512},def:5,blurb:"Vertical spread amount",nick:"Vertical"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:nop",title:"No Operation",description:"No operation (can be used as a routing point)",categories:"core",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:normal-map",title:"Normal Map",description:"Generate a normal map from a height map",categories:"misc",inputs:["input"],outputs:["output"],properties:[{id:"scale",type:"number",range:{min:0},def:10,blurb:"The amount by which to scale the height values",nick:"Scale"},{id:"x-component",type:"enum",elements:[{label:"Red",value:"red"},{label:"Green",value:"green"}],def:"red",blurb:"The component used for the X coordinates",nick:"X Component"},{id:"y-component",type:"enum",elements:[{label:"Red",value:"red"},{label:"Green",value:"green"}],def:"green",blurb:"The component used for the Y coordinates",nick:"Y Component"},{id:"flip-x",type:"boolean",def:!1,blurb:"Flip the X coordinates",nick:"Flip X"},{id:"flip-y",type:"boolean",def:!1,blurb:"Flip the Y coordinates",nick:"Flip Y"},{id:"full-z",type:"boolean",def:!1,blurb:"Use the full [0,1] range to encode the Z coordinates",nick:"Full Z Range"},{id:"tileable",type:"boolean",def:!1,blurb:"Generate a tileable map",nick:"Tileable"}]},{name:"gegl:npd",title:null,description:"Performs n-point image deformation",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"model",type:"gpointer",def:!1,blurb:"Model - basic element we operate on",nick:"Model"},{id:"square-size",type:"int",range:{min:5,max:1e3},def:20,blurb:"Size of an edge of square the mesh consists of",nick:"Square Size"},{id:"rigidity",type:"int",range:{min:0,max:1e4},def:100,blurb:"The number of deformation iterations",nick:"Rigidity"},{id:"asap-deformation",type:"boolean",def:!1,blurb:"ASAP deformation is performed when TRUE, ARAP deformation otherwise",nick:"ASAP Deformation"},{id:"mls-weights",type:"boolean",def:!1,blurb:"Use MLS weights",nick:"MLS Weights"},{id:"mls-weights-alpha",type:"number",range:{min:.1,max:2},def:1,blurb:"Alpha parameter of MLS weights",nick:"MLS Weights Alpha"},{id:"preserve-model",type:"boolean",def:!1,blurb:"When TRUE the model will not be freed",nick:"Preserve Model"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"cubic",blurb:"Sampler used internally",nick:"Sampler"}]},{name:"gegl:npy-save",title:"NumPy File Saver",description:"NumPy (Numerical Python) image saver",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout",nick:"File"}]},{name:"gegl:oilify",title:"Oilify",description:"Emulate an oil painting",categories:"artistic",inputs:["aux2","aux","input"],outputs:["output"],properties:[{id:"mask-radius",type:"int",range:{min:1,max:100},def:4,blurb:"Radius of circle around pixel, can also be scaled per pixel by a buffer on the aux pad.",nick:"Mask Radius"},{id:"exponent",type:"int",range:{min:1,max:20},def:8,blurb:"Exponent for processing; controls smoothness - can be scaled per pixel with a buffer on the aux2 pad.",nick:"Exponent"},{id:"intensities",type:"int",range:{min:8,max:256},def:128,blurb:"Histogram size",nick:"Number of intensities"},{id:"use-inten",type:"boolean",def:!0,blurb:"Use pixel luminance values",nick:"Intensity Mode"}]},{name:"gegl:opacity",title:"Opacity",description:"Weights the opacity of the input both the value of the aux input and the global value property.",categories:"transparency",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",range:{min:-10,max:10},def:1,blurb:"Global opacity value that is always used on top of the optional auxiliary input buffer.",nick:"Opacity"}]},{name:"gegl:open-buffer",title:"Open GEGL Buffer",description:"Use an on-disk GeglBuffer as data source.",categories:"input",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"a GeglBuffer on disk to open",nick:"File"}]},{name:"gegl:panorama-projection",title:"Panorama Projection",description:"Do panorama viewer rendering mapping or its inverse for an equirectangular input image. (2:1 ratio containing 360x180 degree panorama).",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"pan",type:"number",range:{min:-360,max:360},def:0,blurb:"Horizontal camera panning",nick:"Pan"},{id:"tilt",type:"number",range:{min:-180,max:180},def:0,blurb:"Vertical camera panning",nick:"Tilt"},{id:"spin",type:"number",range:{min:-360,max:360},def:0,blurb:"Spin angle around camera axis",nick:"Spin"},{id:"zoom",type:"number",range:{min:.01,max:1e3},def:100,blurb:"Zoom level",nick:"Zoom"},{id:"width",type:"int",range:{min:-1,max:1e4},def:-1,blurb:"output/rendering width in pixels, -1 for input width",nick:"Width"},{id:"height",type:"int",range:{min:-1,max:1e4},def:-1,blurb:"output/rendering height in pixels, -1 for input height",nick:"Height"},{id:"inverse",type:"boolean",def:!1,blurb:"Do the inverse mapping, useful for touching up zenith, nadir or other parts of panorama.",nick:"Inverse transform"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"nearest",blurb:"Image resampling method to use, for good results with double resampling when retouching panoramas, use nearest to generate the view and cubic or better for the inverse transform back to panorama.",nick:"Resampling method"}]},{name:"gegl:path",title:"Render Path",description:"Renders a brush stroke",categories:"render:vector",inputs:["input"],outputs:["output"],properties:[{id:"fill",type:"color",def:"#00000099",blurb:"Color of paint to use for filling, use 0 opacity to disable filling",nick:"Fill Color"},{id:"stroke",type:"color",def:"#00000000",blurb:"Color of paint to use for stroking",nick:"Stroke Color"},{id:"stroke-width",type:"number",range:{min:0,max:200},def:2,blurb:"The width of the brush used to stroke the path",nick:"Stroke width"},{id:"stroke-opacity",type:"number",range:{min:-2,max:2},def:1,blurb:"Opacity of stroke, note, does not behave like SVG since at the moment stroking is done using an airbrush tool",nick:"Stroke opacity"},{id:"stroke-hardness",type:"number",range:{min:0,max:1},def:.6,blurb:"Hardness of the brush, 0.0 for a soft brush, 1.0 for a hard brush",nick:"Hardness"},{id:"fill-rule",type:"string",def:"nonzero",blurb:"How to determine what to fill (nonzero|evenodd)",nick:"Fill rule"},{id:"transform",type:"string",def:"",blurb:"SVG style description of transform",nick:"Transform"},{id:"fill-opacity",type:"number",range:{min:-2,max:2},def:1,blurb:"The fill opacity to use",nick:"Fill opacity"},{id:"d",type:"GeglPath",def:1,blurb:"A GeglVector representing the path of the stroke",nick:"Vector"}]},{name:"gegl:pdf-load",title:"pdf loader",description:"PDF page decoder",categories:"input",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"file to load",nick:"Path"},{id:"uri",type:"string",def:"",blurb:"uri of file to load",nick:"URI"},{id:"page",type:"int",range:{min:1,max:1e4},def:1,blurb:"Page to render",nick:"Page"},{id:"pages",type:"int",range:{min:1,max:1e4},def:1,blurb:"Total pages, provided as a visual read-only property",nick:"Pages"},{id:"ppi",type:"number",range:{min:10,max:2400},def:200,blurb:"Point/pixels per inch",nick:"PPI"},{id:"password",type:"string",def:"",blurb:"Password to use for decryption of PDF, or blank for none",nick:"Password"}]},{name:"gegl:perlin-noise",title:"Perlin Noise",description:"Perlin noise generator",categories:"render",inputs:[],outputs:["output"],properties:[{id:"alpha",type:"number",def:1.2,blurb:null,nick:"Alpha"},{id:"scale",type:"number",def:1.8,blurb:null,nick:"Scale"},{id:"zoff",type:"number",def:-1,blurb:null,nick:"Z offset"},{id:"n",type:"int",range:{min:0,max:20},def:3,blurb:null,nick:"Iterations"}]},{name:"gegl:photocopy",title:"Photocopy",description:"Simulate color distortion produced by a copy machine",categories:"artistic",inputs:["input"],outputs:["output"],properties:[{id:"mask-radius",type:"number",range:{min:0,max:50},def:10,blurb:null,nick:"Mask Radius"},{id:"sharpness",type:"number",range:{min:0,max:1},def:.5,blurb:null,nick:"Sharpness"},{id:"black",type:"number",range:{min:0,max:1},def:.2,blurb:null,nick:"Percent Black"},{id:"white",type:"number",range:{min:0,max:1},def:.2,blurb:null,nick:"Percent White"}]},{name:"gegl:pixbuf",title:"GdkPixbuf Source",description:"Uses the GdkPixbuf located at the memory location in <em>pixbuf</em>.",categories:"programming:input",inputs:[],outputs:["output"],properties:[{id:"pixbuf",type:"GdkPixbuf",def:.2,blurb:"GdkPixbuf to use",nick:"Pixbuf"}]},{name:"gegl:pixelize",title:"Pixelize",description:"Simplify image into an array of solid-colored rectangles",categories:"blur:scramble",inputs:["input"],outputs:["output"],properties:[{id:"norm",type:"enum",elements:[{label:"Diamond",value:"diamond"},{label:"Round",value:"round"}],def:"(null)",blurb:"The shape of pixels",nick:"Shape"},{id:"size-x",type:"int",range:{min:1},def:16,blurb:"Width of blocks in pixels",nick:"Block width"},{id:"size-y",type:"int",range:{min:1},def:16,blurb:"Height of blocks in pixels",nick:"Block height"},{id:"offset-x",type:"int",def:0,blurb:"Horizontal offset of blocks in pixels",nick:"Offset X"},{id:"offset-y",type:"int",def:0,blurb:"Vertical offset of blocks in pixels",nick:"Offset Y"},{id:"ratio-x",type:"number",range:{min:0,max:1},def:1,blurb:"Horizontal size ratio of a pixel inside each block",nick:"Size ratio X"},{id:"ratio-y",type:"number",range:{min:0,max:1},def:1,blurb:"Vertical size ratio of a pixel inside each block",nick:"Size ratio Y"},{id:"background",type:"color",def:"#ffffffff",blurb:"Color used to fill the background",nick:"Background color"}]},{name:"gegl:plasma",title:"Plasma",description:"Creates an image filled with a plasma effect.",categories:"render",inputs:[],outputs:["output"],properties:[{id:"turbulence",type:"number",range:{min:0,max:7},def:1,blurb:"High values give more variation in details",nick:"Turbulence"},{id:"x",type:"int",def:0,blurb:"X start of the generated buffer",nick:"X"},{id:"y",type:"int",def:0,blurb:"Y start of the generated buffer",nick:"Y"},{id:"width",type:"int",range:{min:0},def:1024,blurb:"Width of the generated buffer",nick:"Width"},{id:"height",type:"int",range:{min:0},def:768,blurb:"Height of the generated buffer",nick:"Height"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:png-load",title:"PNG File Loader",description:"PNG image loader.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load.",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI for file to load.",nick:"URI"}]},{name:"gegl:png-save",title:"PNG File Saver",description:"PNG image saver, using libpng",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout.",nick:"File"},{id:"compression",type:"int",range:{min:1,max:9},def:3,blurb:"PNG compression level from 1 to 9",nick:"Compression"},{id:"bitdepth",type:"int",range:{min:8,max:16},def:16,blurb:"8 and 16 are the currently accepted values.",nick:"Bitdepth"}]},{name:"gegl:polar-coordinates",title:"Polar Coordinates",description:"Convert image to or from polar coordinates",categories:"transform:map",inputs:["input"],outputs:["output"],properties:[{id:"depth",type:"number",range:{min:0,max:100},def:100,blurb:null,nick:"Circle depth in percent"},{id:"angle",type:"number",range:{min:0,max:360},def:0,blurb:null,nick:"Offset angle"},{id:"bw",type:"boolean",def:!1,blurb:"Start from the right instead of the left",nick:"Map backwards"},{id:"top",type:"boolean",def:!0,blurb:"Put the top row in the middle and the bottom row on the outside",nick:"Map from top"},{id:"polar",type:"boolean",def:!0,blurb:"Map the image to a circle",nick:"To polar"},{id:"pole-x",type:"int",range:{min:0},def:0,blurb:"Origin point for the polar coordinates",nick:"X"},{id:"pole-y",type:"int",range:{min:0},def:0,blurb:"Origin point for the polar coordinates",nick:"Y"},{id:"middle",type:"boolean",def:!0,blurb:"Let origin point to be the middle one",nick:"Choose middle"}]},{name:"gegl:posterize",title:"Posterize",description:"Reduces the number of levels in each color component of the image.",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"levels",type:"int",range:{min:1,max:64},def:8,blurb:"number of levels per component",nick:"Levels"}]},{name:"gegl:ppm-load",title:"PPM File Loader",description:"PPM image loader.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load.",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI of image to load.",nick:"URI"}]},{name:"gegl:ppm-save",title:"PPM File Saver",description:"PPM image saver (Portable pixmap saver.)",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout.",nick:"File"},{id:"rawformat",type:"boolean",def:!0,blurb:null,nick:"Raw format"},{id:"bitdepth",type:"int",range:{min:8,max:16},def:16,blurb:"8 and 16 are the currently accepted values.",nick:"Bitdepth"}]},{name:"gegl:radial-gradient",title:"Radial Gradient",description:"Radial gradient renderer",categories:"render:gradient",inputs:[],outputs:["output"],properties:[{id:"start-x",type:"number",def:25,blurb:null,nick:"X1"},{id:"start-y",type:"number",def:25,blurb:null,nick:"Y1"},{id:"end-x",type:"number",def:50,blurb:null,nick:"X2"},{id:"end-y",type:"number",def:50,blurb:null,nick:"Y2"},{id:"start-color",type:"color",def:"#000000ff",blurb:"The color at (x1, y1)",nick:"Start Color"},{id:"end-color",type:"color",def:"#ffffffff",blurb:"The color at (x2, y2)",nick:"End Color"}]},{name:"gegl:raw-load",title:"libraw File Loader",description:"Camera RAW image loader",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load.",nick:"File"},{id:"image-num",type:"int",def:0,blurb:null,nick:"Image number"},{id:"color-space",type:"enum",elements:[{label:"Camera RGB",value:"camera"},{label:"s RGB",value:"sRGB"},{label:"Adobe RGB compatible",value:"Adobish"},{label:"Wide gamut RGB",value:"Wide gamut"}],def:"sRGB",blurb:"Color space to use for loaded data",nick:"Color space"},{id:"quality",type:"int",def:10,blurb:null,nick:"quality"}]},{name:"gegl:rectangle",title:"Rectangle",description:"A rectangular source of a fixed size with a solid color",categories:"render",inputs:[],outputs:["output"],properties:[{id:"x",type:"number",def:42,blurb:"Horizontal position",nick:"X"},{id:"y",type:"number",def:42,blurb:"Vertical position",nick:"Y"},{id:"width",type:"number",range:{min:0},def:23,blurb:"Horizontal extent",nick:"Width"},{id:"height",type:"number",range:{min:0},def:42,blurb:"Vertical extent",nick:"Height"},{id:"color",type:"color",def:"#008000ff",blurb:"Color to render",nick:"Color"}]},{name:"gegl:recursive-transform",title:"Recursive Transform",description:"Apply a transformation recursively.",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"transform",type:"string",def:"matrix (1, 0, 0, 0, 1, 0, 0, 0, 1)",blurb:"Transformation matrix, using SVG syntax (or multiple matrices, separated by semicolons)",nick:"Transform"},{id:"first-iteration",type:"int",range:{min:0,max:20},def:0,blurb:"First iteration",nick:"First iteration"},{id:"iterations",type:"int",range:{min:0,max:20},def:3,blurb:"Number of iterations",nick:"Iterations"},{id:"fade-color",type:"color",def:"#00000000",blurb:"Color to fade transformed images towards, with a rate depending on its alpha",nick:"Fade color"},{id:"fade-opacity",type:"number",range:{min:0,max:1},def:1,blurb:"Amount by which to scale the opacity of each transformed image",nick:"Fade opacity"},{id:"paste-below",type:"boolean",def:!1,blurb:"Paste transformed images below each other",nick:"Paste below"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Mathematical method for reconstructing pixel values",nick:"Resampling method"}]},{name:"gegl:red-eye-removal",title:"Red Eye Removal",description:"Remove the red eye effect caused by camera flashes",categories:"enhance",inputs:["input"],outputs:["output"],properties:[{id:"threshold",type:"number",range:{min:0,max:.8},def:.4,blurb:"Red eye threshold",nick:"Threshold"}]},{name:"gegl:reflect",title:"Reflect",description:"Reflect an image about a line, whose direction is specified by the vector that is defined by the x and y properties. ",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"x",type:"number",def:0,blurb:"Direction vector's X component",nick:"X"},{id:"y",type:"number",def:0,blurb:"Direction vector's Y component",nick:"Y"}]},{name:"gegl:reinhard05",title:"Reinhard 2005 Tone Mapping",description:"Adapt an image, which may have a high dynamic range, for presentation using a low dynamic range. This is an efficient global operator derived from simple physiological observations, producing luminance within the range 0.0-1.0",categories:"tonemapping",inputs:["input"],outputs:["output"],properties:[{id:"brightness",type:"number",range:{min:-100,max:100},def:0,blurb:"Overall brightness of the image",nick:"Brightness"},{id:"chromatic",type:"number",range:{min:0,max:1},def:0,blurb:"Adaptation to color variation across the image",nick:"Chromatic adaptation"},{id:"light",type:"number",range:{min:0,max:1},def:1,blurb:"Adaptation to light variation across the image",nick:"Light adaptation"}]},{name:"gegl:remap",title:"Remap",description:"stretch components of pixels individually based on luminance envelopes",categories:"compositors",inputs:["aux2","aux","input"],outputs:["output"],properties:[]},{name:"gegl:rgb-clip",title:"Clip RGB",description:"Keep RGB pixels values inside a specific range",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"clip-low",type:"boolean",def:!0,blurb:"Clip low pixel values",nick:"Clip low pixel values"},{id:"low-limit",type:"number",range:{max:0},def:0,blurb:"Pixels values lower than this limit will be set to it",nick:"Low limit"},{id:"clip-high",type:"boolean",def:!0,blurb:"Clip high pixel values",nick:"Clip high pixel values"},{id:"high-limit",type:"number",range:{min:1},def:1,blurb:"Pixels values higher than this limit will be set to it",nick:"High limit"}]},{name:"gegl:rgbe-load",title:"RGBE File Loader",description:"RGBE image loader (Radiance HDR format).",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load.",nick:"File"}]},{name:"gegl:rgbe-save",title:"RGBE File Saver",description:"RGBE image saver (Radiance HDR format)",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout.",nick:"File"}]},{name:"gegl:ripple",title:"Ripple",description:"Displace pixels in a ripple pattern",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"amplitude",type:"number",range:{min:0,max:1e3},def:25,blurb:null,nick:"Amplitude"},{id:"period",type:"number",range:{min:0,max:1e3},def:200,blurb:null,nick:"Period"},{id:"phi",type:"number",range:{min:-1,max:1},def:0,blurb:null,nick:"Phase shift"},{id:"angle",type:"number",range:{min:-180,max:180},def:0,blurb:null,nick:"Angle"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"cubic",blurb:null,nick:"Resampling method"},{id:"wave-type",type:"enum",elements:[{label:"Sine",value:"sine"},{label:"Triangle",value:"triangle"}],def:"sine",blurb:null,nick:"Wave type"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"none",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"tileable",type:"boolean",def:!1,blurb:"Retain tilebility",nick:"Tileable"}]},{name:"gegl:rotate",title:"Rotate",description:"Rotate the buffer around the specified origin.",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"degrees",type:"number",range:{min:-720,max:720},def:0,blurb:"Angle to rotate (counter-clockwise)",nick:"Degrees"}]},{name:"gegl:rotate-on-center",title:"Rotate on center",description:"Rotate the buffer around its center, taking care of possible offsets.",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"degrees",type:"number",def:0,blurb:"Angle to rotate (counter-clockwise)",nick:"Degrees"},{id:"origin-x",type:"number",def:0,blurb:"Ignored. Always uses center of input buffer",nick:"origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Ignored. Always uses center of input buffer",nick:"origin-y"}]},{name:"gegl:saturation",title:"Saturation",description:"Changes the saturation",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"scale",type:"number",range:{min:0,max:10},def:1,blurb:"Scale, strength of effect",nick:"Scale"},{id:"colorspace",type:"enum",elements:[{label:"Native",value:"Native"},{label:"CIE Lab/Lch",value:"CIE-Lab"}],def:"Native",blurb:null,nick:"Interpolation Color Space"}]},{name:"gegl:save",title:"Save",description:"Multipurpose file saver, that uses other native save handlers depending on extension, use the format specific save ops to specify additional parameters.",categories:"meta:output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to save.",nick:"File"}]},{name:"gegl:save-pixbuf",title:"Store in GdkPixbuf",description:"Store image in a GdkPixbuf.",categories:"programming:output",inputs:["input"],outputs:[],properties:[{id:"pixbuf",type:"gpointer",def:"",blurb:null,nick:"Pixbuf location"}]},{name:"gegl:scale-ratio",title:"Scale ratio",description:"Scales the buffer according to a ratio.",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"none",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"x",type:"number",range:{min:-9e3,max:9e3},def:0,blurb:"Horizontal scale factor",nick:"X"},{id:"y",type:"number",range:{min:-9e3,max:9e3},def:0,blurb:"Vertical scale factor",nick:"Y"}]},{name:"gegl:scale-size",title:"Scale size",description:"Scales the buffer according to a size.",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"none",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"x",type:"number",range:{min:-9e3,max:9e3},def:100,blurb:"Horizontal size",nick:"X"},{id:"y",type:"number",range:{min:-9e3,max:9e3},def:100,blurb:"Vertical size",nick:"Y"}]},{name:"gegl:scale-size-keepaspect",title:"Scale size keep aspect",description:"Scales the buffer to a size, preserving aspect ratio",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"abyss-policy",type:"enum",elements:[{label:"None",value:"none"},{label:"Clamp",value:"clamp"},{label:"Loop",value:"loop"},{label:"Black",value:"black"}],def:"none",blurb:"How image edges are handled",nick:"Abyss policy"},{id:"x",type:"number",range:{min:-9e3,max:9e3},def:-1,blurb:"Horizontal size",nick:"X"},{id:"y",type:"number",range:{min:-9e3,max:9e3},def:-1,blurb:"Vertical size",nick:"Y"}]},{name:"gegl:sdl2-display",title:"SDL2 Display",description:"Displays the input buffer in an SDL2 window (restricted to one display op/process, due to SDL2 implementation issues).",categories:"display",inputs:["input"],outputs:[],properties:[{id:"window-title",type:"string",def:"window_title",blurb:"Title to be given to output window",nick:"Window title"}]},{name:"gegl:seamless-clone",title:null,description:"Seamless cloning operation",categories:"blend",inputs:["aux","input"],outputs:["output"],properties:[{id:"max-refine-scale",type:"int",range:{min:0,max:1e5},def:5,blurb:"Maximal scale of refinement points to be used for the interpolation mesh",nick:"Refinement scale"},{id:"xoff",type:"int",range:{min:-1e5,max:1e5},def:0,blurb:"How much horizontal offset should applied to the paste",nick:"Offset X"},{id:"yoff",type:"int",range:{min:-1e5,max:1e5},def:0,blurb:"How much horizontal offset should applied to the paste",nick:"Offset Y"},{id:"error-msg",type:"string",def:"",blurb:"An error message in case of a failure",nick:"Error message"}]},{name:"gegl:seamless-clone-compose",title:null,description:"Seamless cloning composite operation",categories:"compositors:meta:blend",inputs:["aux","input"],outputs:["output"],properties:[{id:"max-refine-scale",type:"int",range:{min:0,max:1e5},def:2e3,blurb:"Maximal amount of refinement points to be used for the interpolation mesh",nick:"Refinement steps"},{id:"xoff",type:"int",range:{min:0,max:1e5},def:0,blurb:"How much horizontal offset should applied to the paste",nick:"Offset X"},{id:"yoff",type:"int",range:{min:0,max:1e5},def:0,blurb:"How much vertical offset should applied to the paste",nick:"Offset Y"},{id:"error-msg",type:"string",def:"",blurb:"An error message in case of a failure",nick:"Error message"}]},{name:"gegl:sepia",title:"Sepia",description:"Apply a sepia tone to the input image",categories:"color",inputs:["input"],outputs:["output"],properties:[{id:"scale",type:"number",range:{min:0,max:1},def:1,blurb:"Strength of the sepia effect",nick:"Effect strength"},{id:"srgb",type:"boolean",def:!0,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"gegl:shadows-highlights",title:"Shadows-Highlights",description:"Perform shadows and highlights correction",categories:"light",inputs:["input"],outputs:["output"],properties:[{id:"shadows",type:"number",range:{min:-100,max:100},def:0,blurb:"Adjust exposure of shadows",nick:"Shadows"},{id:"highlights",type:"number",range:{min:-100,max:100},def:0,blurb:"Adjust exposure of highlights",nick:"Highlights"},{id:"whitepoint",type:"number",range:{min:-10,max:10},def:0,blurb:"Shift white point",nick:"White point adjustment"},{id:"radius",type:"number",range:{min:.1,max:1500},def:100,blurb:"Spatial extent",nick:"Radius"},{id:"compress",type:"number",range:{min:0,max:100},def:50,blurb:"Compress the effect on shadows/highlights and preserve midtones",nick:"Compress"},{id:"shadows-ccorrect",type:"number",range:{min:0,max:100},def:100,blurb:"Adjust saturation of shadows",nick:"Shadows color adjustment"},{id:"highlights-ccorrect",type:"number",range:{min:0,max:100},def:50,blurb:"Adjust saturation of highlights",nick:"Highlights color adjustment"}]},{name:"gegl:shadows-highlights-correction",title:null,description:"Lighten shadows and darken highlights",categories:"hidden",inputs:["aux","input"],outputs:["output"],properties:[{id:"shadows",type:"number",range:{min:-100,max:100},def:0,blurb:"Adjust exposure of shadows",nick:"Shadows"},{id:"highlights",type:"number",range:{min:-100,max:100},def:0,blurb:"Adjust exposure of highlights",nick:"Highlights"},{id:"whitepoint",type:"number",range:{min:-10,max:10},def:0,blurb:"Shift white point",nick:"White point adjustment"},{id:"compress",type:"number",range:{min:0,max:100},def:50,blurb:"Compress the effect on shadows/highlights and preserve midtones",nick:"Compress"},{id:"shadows-ccorrect",type:"number",range:{min:0,max:100},def:100,blurb:"Adjust saturation of shadows",nick:"Shadows color adjustment"},{id:"highlights-ccorrect",type:"number",range:{min:0,max:100},def:50,blurb:"Adjust saturation of highlights",nick:"Highlights color adjustment"}]},{name:"gegl:shear",title:"Shear",description:"Shears the buffer. ",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"x",type:"number",def:0,blurb:"Horizontal shear amount",nick:"X"},{id:"y",type:"number",def:0,blurb:"Vertical shear amount",nick:"Y"}]},{name:"gegl:shift",title:"Shift",description:"Shift each row or column of pixels by a random amount",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"shift",type:"int",range:{min:0,max:200},def:5,blurb:"Maximum amount to shift",nick:"Shift"},{id:"direction",type:"enum",elements:[{label:"Horizontal",value:"horizontal"}],def:"horizontal",blurb:null,nick:"Shift direction"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:simplex-noise",title:"Simplex Noise",description:"Generates a solid noise texture.",categories:"render",inputs:[],outputs:["output"],properties:[{id:"scale",type:"number",range:{min:0,max:20},def:1,blurb:"The scale of the noise function",nick:"Scale"},{id:"iterations",type:"int",range:{min:1,max:20},def:1,blurb:"The number of noise octaves.",nick:"Iterations"},{id:"seed",type:"int",def:0,blurb:"The random seed for the noise function",nick:"Random seed"}]},{name:"gegl:sinus",title:"Sinus",description:"Generate complex sinusoidal textures",categories:"render",inputs:[],outputs:["output"],properties:[{id:"x-scale",type:"number",range:{min:0},def:15,blurb:"Scale value for x axis",nick:"X Scale"},{id:"y-scale",type:"number",range:{min:0},def:15,blurb:"Scale value for y axis",nick:"Y Scale"},{id:"complexity",type:"number",range:{min:0,max:15},def:1,blurb:"Complexity factor",nick:"Complexity"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"},{id:"tiling",type:"boolean",def:!0,blurb:"If set, the pattern generated will tile",nick:"Force tiling"},{id:"perturbation",type:"boolean",def:!0,blurb:"If set, the pattern will be a little more distorted",nick:"Distorted"},{id:"color1",type:"color",def:"#ffff00ff",blurb:null,nick:"Color 1"},{id:"color2",type:"color",def:"#0000ffff",blurb:null,nick:"Color 2"},{id:"blend-mode",type:"enum",elements:[{label:"Linear",value:"linear"},{label:"Bilinear",value:"bilinear"}],def:"(null)",blurb:null,nick:"Blend Mode"},{id:"blend-power",type:"number",range:{min:-7.5,max:7.5},def:0,blurb:"Power used to stretch the blend",nick:"Exponent"},{id:"width",type:"int",range:{min:0},def:1024,blurb:"Width of the generated buffer",nick:"Width"},{id:"height",type:"int",range:{min:0},def:768,blurb:"Height of the generated buffer",nick:"Height"}]},{name:"gegl:slic",title:"Simple Linear Iterative Clustering",description:"Superpixels based on k-means clustering",categories:"color:segmentation",inputs:["input"],outputs:["output"],properties:[{id:"cluster-size",type:"int",range:{min:2},def:32,blurb:"Size of a region side",nick:"Regions size"},{id:"compactness",type:"int",range:{min:1,max:40},def:20,blurb:"Cluster size",nick:"Compactness"},{id:"iterations",type:"int",range:{min:1,max:30},def:1,blurb:"Number of iterations",nick:"Iterations"}]},{name:"gegl:snn-mean",title:"Symmetric Nearest Neighbour",description:"Noise reducing edge preserving blur filter based on Symmetric Nearest Neighbours",categories:"enhance:noise-reduction",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"int",range:{min:0,max:100},def:8,blurb:"Radius of square pixel region, (width and height will be radius*2+1)",nick:"Radius"},{id:"pairs",type:"int",range:{min:1,max:2},def:2,blurb:"Number of pairs; higher number preserves more acute features",nick:"Pairs"}]},{name:"gegl:soft-light",title:"Soft-light",description:"SVG blend operation soft-light (<code>if 2 * cA < aA: d = cB * (aA - (aB == 0 ? 1 : 1 - cB / aB) * (2 * cA - aA)) + cA * (1 - aB) + cB * (1 - aA); if 8 * cB <= aB: d = cB * (aA - (aB == 0 ? 1 : 1 - cB / aB) * (2 * cA - aA) * (aB == 0 ? 3 : 3 - 8 * cB / aB)) + cA * (1 - aB) + cB * (1 - aA); otherwise: d = (aA * cB + (aB == 0 ? 0 : sqrt (cB / aB) * aB - cB) * (2 * cA - aA)) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"gegl:softglow",title:"Softglow",description:"Simulate glow by making highlights intense and fuzzy",categories:"artistic",inputs:["input"],outputs:["output"],properties:[{id:"glow-radius",type:"number",range:{min:1,max:50},def:10,blurb:null,nick:"Glow radius"},{id:"brightness",type:"number",range:{min:0,max:1},def:.3,blurb:null,nick:"Brightness"},{id:"sharpness",type:"number",range:{min:0,max:1},def:.85,blurb:null,nick:"Sharpness"}]},{name:"gegl:spherize",title:"Spherize",description:"Wrap image around a spherical cap",categories:"distort:map",inputs:["input"],outputs:["output"],properties:[{id:"mode",type:"enum",elements:[{label:"Radial",value:"radial"},{label:"Horizontal",value:"horizontal"}],def:"radial",blurb:"Displacement mode",nick:"Mode"},{id:"angle-of-view",type:"number",range:{min:0,max:180},def:0,blurb:"Camera angle of view",nick:"Angle of view"},{id:"curvature",type:"number",range:{min:0,max:1},def:1,blurb:"Spherical cap apex angle, as a fraction of the co-angle of view",nick:"Curvature"},{id:"amount",type:"number",range:{min:-1,max:1},def:1,blurb:"Displacement scaling factor (negative values refer to the inverse displacement)",nick:"Amount"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Mathematical method for reconstructing pixel values",nick:"Resampling method"}]},{name:"gegl:spiral",title:"Spiral",description:"Spiral renderer",categories:"render",inputs:[],outputs:["output"],properties:[{id:"type",type:"enum",elements:[{label:"Linear",value:"linear"}],def:"linear",blurb:"Spiral type",nick:"Type"},{id:"x",type:"number",def:.5,blurb:"Spiral origin X coordinate",nick:"X"},{id:"y",type:"number",def:.5,blurb:"Spiral origin Y coordinate",nick:"Y"},{id:"radius",type:"number",range:{min:1},def:100,blurb:"Spiral radius",nick:"Radius"},{id:"base",type:"number",range:{min:1},def:2,blurb:"Logarithmic spiral base",nick:"Base"},{id:"balance",type:"number",range:{min:-1,max:1},def:0,blurb:"Area balance between the two colors",nick:"Balance"},{id:"rotation",type:"number",range:{min:0,max:360},def:0,blurb:"Spiral rotation",nick:"Rotation"},{id:"direction",type:"enum",elements:[{label:"Clockwise",value:"cw"}],def:"cw",blurb:"Spiral swirl direction",nick:"Direction"},{id:"color1",type:"color",def:"#000000ff",blurb:null,nick:"Color 1"},{id:"color2",type:"color",def:"#ffffffff",blurb:null,nick:"Color 2"},{id:"width",type:"int",range:{min:0},def:1024,blurb:"Width of the generated buffer",nick:"Width"},{id:"height",type:"int",range:{min:0},def:768,blurb:"Height of the generated buffer",nick:"Height"}]},{name:"gegl:stereographic-projection",title:"Little Planet",description:"Do a stereographic/little planet transform of an equirectangular image.",categories:"map",inputs:["input"],outputs:["output"],properties:[{id:"pan",type:"number",range:{min:-360,max:360},def:0,blurb:"Horizontal camera panning",nick:"Pan"},{id:"tilt",type:"number",range:{min:-180,max:180},def:90,blurb:"Vertical camera panning",nick:"Tilt"},{id:"spin",type:"number",range:{min:-360,max:360},def:0,blurb:"Spin angle around camera axis",nick:"Spin"},{id:"zoom",type:"number",range:{min:.01,max:1e3},def:100,blurb:"Zoom level",nick:"Zoom"},{id:"width",type:"int",range:{min:-1,max:1e4},def:-1,blurb:"output/rendering width in pixels, -1 for input width",nick:"Width"},{id:"height",type:"int",range:{min:-1,max:1e4},def:-1,blurb:"output/rendering height in pixels, -1 for input height",nick:"Height"},{id:"inverse",type:"boolean",def:!1,blurb:"Do the inverse mapping, useful for touching up zenith, nadir or other parts of panorama.",nick:"Inverse transform"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"nearest",blurb:"Image resampling method to use, for good results with double resampling when retouching panoramas, use nearest to generate the view and cubic or better for the inverse transform back to panorama.",nick:"Resampling method"}]},{name:"gegl:stress",title:"Spatio Temporal Retinex-like Envelope with Stochastic Sampling",description:"Spatio Temporal Retinex-like Envelope with Stochastic Sampling",categories:"enhance:tonemapping",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"int",range:{min:2,max:6e3},def:300,blurb:"Neighborhood taken into account, for enhancement ideal values are close to the longest side of the image, increasing this increases the runtime",nick:"Radius"},{id:"samples",type:"int",range:{min:2,max:500},def:5,blurb:"Number of samples to do per iteration looking for the range of colors",nick:"Samples"},{id:"iterations",type:"int",range:{min:1,max:1e3},def:5,blurb:"Number of iterations, a higher number of iterations provides a less noisy rendering at a computational cost",nick:"Iterations"},{id:"enhance-shadows",type:"boolean",def:!1,blurb:"When enabled also enhances shadow regions - when disabled a more natural result is yielded",nick:"Enhance Shadows"}]},{name:"gegl:stretch-contrast",title:"Stretch Contrast",description:"Scales the components of the buffer to be in the 0.0-1.0 range. This improves images that make poor use of the available contrast (little contrast, very dark, or very bright images).",categories:"color:enhance",inputs:["input"],outputs:["output"],properties:[{id:"keep-colors",type:"boolean",def:!0,blurb:"Impact each channel with the same amount",nick:"Keep colors"},{id:"perceptual",type:"boolean",def:!1,blurb:"When set operate on gamma corrected values instead of linear RGB - acting like the old normalize filter in GIMP",nick:"Non-linear components"}]},{name:"gegl:stretch-contrast-hsv",title:"Stretch Contrast HSV",description:"Scales the components of the buffer to be in the 0.0-1.0 range. This improves images that make poor use of the available contrast (little contrast, very dark, or very bright images). This version differs from Contrast Autostretch in that it works in HSV space, and preserves hue.",categories:"color:enhance",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:subtract",title:"Subtract",description:"Math operation subtract, performs the operation per pixel, using either the constant provided in 'value' or the corresponding pixel from the buffer on aux as operands. The result is the evaluation of the expression result = input - value",categories:"compositors:math",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",def:0,blurb:"global value used if aux doesn't contain data",nick:"Value"}]},{name:"gegl:supernova",title:"Supernova",description:"This plug-in produces an effect like a supernova burst. The amount of the light effect is approximately in proportion to 1/r, where r is the distance from the center of the star.",categories:"light",inputs:["input"],outputs:["output"],properties:[{id:"center-x",type:"number",def:.5,blurb:"X coordinates of the center of supernova",nick:"Center X"},{id:"center-y",type:"number",def:.5,blurb:"Y coordinates of the center of supernova",nick:"Center Y"},{id:"radius",type:"int",range:{min:1,max:2e4},def:20,blurb:"Radius of supernova",nick:"Radius"},{id:"spokes-count",type:"int",range:{min:1,max:1024},def:100,blurb:"Number of spokes",nick:"Number of spokes"},{id:"random-hue",type:"int",range:{min:0,max:360},def:0,blurb:"Random hue",nick:"Random hue"},{id:"color",type:"color",def:"#0000ffff",blurb:"The color of supernova.",nick:"Color"},{id:"seed",type:"int",def:0,blurb:"The random seed for spokes and random hue",nick:"Random seed"}]},{name:"gegl:svg-huerotate",title:"SVG Hue Rotate",description:"SVG color matrix operation svg_huerotate",categories:"compositors:svgfilter",inputs:["input"],outputs:["output"],properties:[{id:"values",type:"string",def:"",blurb:"list of <number>s",nick:"Values"}]},{name:"gegl:svg-load",title:"SVG File Loader",description:"Load an SVG file using librsvg",categories:"input",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI for file to load",nick:"URI"},{id:"width",type:"int",def:-1,blurb:"Width for rendered image",nick:"Width"},{id:"height",type:"int",def:-1,blurb:"Height for rendered image",nick:"Height"}]},{name:"gegl:svg-luminancetoalpha",title:"SVG Luminance to Alpha",description:"SVG color matrix operation svg_luminancetoalpha",categories:"compositors:svgfilter",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:svg-matrix",title:"SVG Matrix",description:"SVG color matrix operation svg_matrix",categories:"compositors:svgfilter",inputs:["input"],outputs:["output"],properties:[{id:"values",type:"string",def:"",blurb:"list of <number>s",nick:"Values"}]},{name:"gegl:svg-saturate",title:"SVG Saturate",description:"SVG color matrix operation svg_saturate",categories:"compositors:svgfilter",inputs:["input"],outputs:["output"],properties:[{id:"values",type:"string",def:"",blurb:"list of <number>s",nick:"Values"}]},{name:"gegl:text",title:"Render Text",description:"Display a string of text using pango and cairo.",categories:"render",inputs:[],outputs:["output"],properties:[{id:"string",type:"string",def:"Hello",blurb:"String to display (utf8)",nick:"Text"},{id:"font",type:"string",def:"Sans",blurb:"Font family (utf8)",nick:"Font family"},{id:"size",type:"number",range:{min:0,max:2048},def:10,blurb:"Font size in pixels.",nick:"Size"},{id:"color",type:"color",def:"#000000ff",blurb:"Color for the text (defaults to 'black')",nick:"Color"},{id:"wrap",type:"int",range:{min:-1,max:1e6},def:-1,blurb:"Sets the width in pixels at which long lines will wrap. Use -1 for no wrapping.",nick:"Wrap width"},{id:"vertical-wrap",type:"int",range:{min:-1,max:1e6},def:-1,blurb:"Sets the height in pixels according to which the text is vertically justified. Use -1 for no vertical justification.",nick:"Wrap height"},{id:"alignment",type:"int",range:{min:0,max:2},def:0,blurb:"Alignment for multi-line text (0=Left, 1=Center, 2=Right)",nick:"Justification"},{id:"vertical-alignment",type:"int",range:{min:0,max:2},def:0,blurb:"Vertical text alignment (0=Top, 1=Middle, 2=Bottom)",nick:"Vertical justification"},{id:"width",type:"int",def:0,blurb:"Rendered width in pixels. (read only)",nick:"Width"},{id:"height",type:"int",def:0,blurb:"Rendered height in pixels. (read only)",nick:"Height"}]},{name:"gegl:texturize-canvas",title:"Texturize Canvas",description:"Textures the image as if it were an artist's canvas.",categories:"artistic",inputs:["input"],outputs:["output"],properties:[{id:"direction",type:"enum",elements:[{label:"Top-right",value:"top-right"},{label:"Top-left",value:"top-left"},{label:"Bottom-left",value:"bottom-left"}],def:"top-right",blurb:"Position of the light source which lightens the canvas: Top-right, Top-left, Bottom-left or Bottom-right",nick:"Direction"},{id:"depth",type:"int",range:{min:1,max:50},def:4,blurb:"Apparent depth of the rendered canvas effect; from 1 (very flat) to 50 (very deep)",nick:"Depth"}]},{name:"gegl:threshold",title:"Threshold",description:"Thresholds the image to white/black based on either the global value set in the value property, or per pixel from the aux input.",categories:"color",inputs:["aux","input"],outputs:["output"],properties:[{id:"value",type:"number",range:{min:-200,max:200},def:.5,blurb:"Scalar threshold level (overridden if an auxiliary input buffer is provided.).",nick:"Threshold"}]},{name:"gegl:tiff-load",title:"TIFF File Loader",description:"TIFF image loader using libtiff",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI for file to load",nick:"URI"},{id:"directory",type:"int",range:{min:1},def:1,blurb:"Image file directory (subfile)",nick:"Directory"}]},{name:"gegl:tiff-save",title:"TIFF File Saver",description:"TIFF image saver using libtiff",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout",nick:"File"},{id:"bitdepth",type:"int",range:{min:-1,max:64},def:-1,blurb:"-1, 8, 16, 32 and 64 are the currently accepted values, -1 means auto",nick:"Bitdepth"},{id:"fp",type:"int",range:{min:-1,max:1},def:-1,blurb:"floating point -1 means auto, 0 means integer 1 meant float.",nick:"use floating point"}]},{name:"gegl:tile",title:"Tile",description:"Infinitely repeats the input image.",categories:"tile",inputs:["input"],outputs:["output"],properties:[{id:"offset-x",type:"int",def:0,blurb:null,nick:"Horizontal offset"},{id:"offset-y",type:"int",def:0,blurb:null,nick:"Vertical offset"}]},{name:"gegl:tile-glass",title:"Tile Glass",description:"Simulate distortion caused by rectangular glass tiles",categories:"artistic:map",inputs:["input"],outputs:["output"],properties:[{id:"tile-width",type:"int",range:{min:5,max:500},def:25,blurb:null,nick:"Tile Width"},{id:"tile-height",type:"int",range:{min:5,max:500},def:25,blurb:null,nick:"Tile Height"}]},{name:"gegl:tile-paper",title:"Paper Tile",description:"Cut image into paper tiles, and slide them",categories:"artistic:map",inputs:["input"],outputs:["output"],properties:[{id:"tile-width",type:"int",range:{min:1},def:155,blurb:"Width of the tile",nick:"Tile Width"},{id:"tile-height",type:"int",range:{min:1},def:56,blurb:"Height of the tile",nick:"Tile Height"},{id:"move-rate",type:"number",range:{min:1,max:100},def:25,blurb:"Move rate",nick:"Move rate"},{id:"wrap-around",type:"boolean",def:!1,blurb:"Wrap the fractional tiles",nick:"Wrap around"},{id:"fractional-type",type:"enum",elements:[{label:"Background",value:"background"},{label:"Ignore",value:"ignore"}],def:"(null)",blurb:"Fractional Type",nick:"Fractional type"},{id:"centering",type:"boolean",def:!0,blurb:"Centering of the tiles",nick:"Centering"},{id:"background-type",type:"enum",elements:[{label:"Transparent",value:"transparent"},{label:"Inverted image",value:"invert"},{label:"Image",value:"image"}],def:"invert",blurb:"Background type",nick:"Background type"},{id:"bg-color",type:"color",def:"#000000ff",blurb:"The tiles' background color",nick:"Background color"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:tile-seamless",title:"Make Seamlessly tileable",description:"Make the input buffer seamlessly tileable. The algorithm is not content-aware, so the result may need post-processing.",categories:"tile",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:transform",title:"Transform",description:"Do a transformation using SVG syntax transformation.",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"transform",type:"string",def:"",blurb:"Transformation SVG syntax transformation string",nick:"Transform"}]},{name:"gegl:translate",title:"Translate",description:"Repositions the buffer (with subpixel precision), if integer coordinates are passed a fast-path without resampling is used",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"origin-x",type:"number",def:0,blurb:"X coordinate of origin",nick:"Origin-x"},{id:"origin-y",type:"number",def:0,blurb:"Y coordinate of origin",nick:"Origin-y"},{id:"near-z",type:"number",range:{min:0,max:1},def:0,blurb:"Z coordinate of the near clipping plane",nick:"Near-z"},{id:"sampler",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"linear",blurb:"Sampler used internally",nick:"Sampler"},{id:"x",type:"number",def:0,blurb:"Horizontal translation",nick:"X"},{id:"y",type:"number",def:0,blurb:"Vertical translation",nick:"Y"}]},{name:"gegl:unpremultiply",title:"Unpremultiply alpha",description:"Unpremultiplies a buffer that contains pre-multiplied colors (but according to the babl format is not.)",categories:"color",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:unsharp-mask",title:"Sharpen (Unsharp Mask)",description:"Sharpen image, by adding difference to blurred image, a technique for sharpening originally used in darkrooms.",categories:"enhance:sharpen",inputs:["input"],outputs:["output"],properties:[{id:"std-dev",type:"number",range:{min:0,max:1500},def:3,blurb:"Expressed as standard deviation, in pixels",nick:"Radius"},{id:"scale",type:"number",range:{min:0,max:300},def:.5,blurb:"Scaling factor for unsharp-mask, the strength of effect",nick:"Amount"},{id:"threshold",type:"number",range:{min:0,max:1},def:0,blurb:null,nick:"Threshold"}]},{name:"gegl:v4l",title:"Video4Linux Frame Source",description:"Video4Linux input, webcams framegrabbers and similar devices.",categories:"input:video",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"/dev/video0",blurb:"Path to v4l device",nick:"Path"},{id:"width",type:"int",range:{min:0},def:320,blurb:"Width for rendered image",nick:"Width"},{id:"height",type:"int",range:{min:0},def:240,blurb:"Height for rendered image",nick:"Height"},{id:"frame",type:"int",range:{min:0},def:0,blurb:"current frame number, can be changed to trigger a reload of the image.",nick:"Frame"},{id:"fps",type:"int",range:{min:0},def:0,blurb:"autotrigger reload this many times a second.",nick:"FPS"}]},{name:"gegl:value-invert",title:"Value Invert",description:"Invert the value component, the result has the brightness inverted, keeping the color.",categories:"color",inputs:["input"],outputs:["output"],properties:[]},{name:"gegl:value-propagate",title:"Value Propagate",description:"Propagate certain values to neighboring pixels. Erode and dilate any color or opacity.",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"mode",type:"enum",elements:[{label:"More white (larger value)",value:"white"},{label:"More black (smaller value)",value:"black"},{label:"Middle value to peaks",value:"middle"},{label:"Color to peaks",value:"color-peak"},{label:"Only color",value:"color"},{label:"More opaque",value:"opaque"}],def:"white",blurb:"Mode of value propagation",nick:"Mode"},{id:"lower-threshold",type:"number",range:{min:0,max:1},def:0,blurb:"The minimum difference in value at which to propagate a pixel",nick:"Lower threshold"},{id:"upper-threshold",type:"number",range:{min:0,max:1},def:1,blurb:"The maximum difference in value at which to propagate a pixel",nick:"Upper threshold"},{id:"rate",type:"number",range:{min:0,max:1},def:1,blurb:"The strength with which to propagate a pixel to its neighbors",nick:"Propagating rate"},{id:"color",type:"color",def:"#0000ffff",blurb:'Color to use for the "Only color" and "Color to peaks" modes',nick:"Color"},{id:"top",type:"boolean",def:!0,blurb:"Propagate to top",nick:"To top"},{id:"left",type:"boolean",def:!0,blurb:"Propagate to left",nick:"To left"},{id:"right",type:"boolean",def:!0,blurb:"Propagate to right",nick:"To right"},{id:"bottom",type:"boolean",def:!0,blurb:"Propagate to bottom",nick:"To bottom"},{id:"value",type:"boolean",def:!0,blurb:"Whether to propagate a pixel's color",nick:"Propagating value channel"},{id:"alpha",type:"boolean",def:!0,blurb:"Whether to propagate a pixel's opacity",nick:"Propagating alpha channel"}]},{name:"gegl:vector-stroke",title:"Vector Stroke",description:"Renders a vector stroke",categories:"render:vector",inputs:["input"],outputs:["output"],properties:[{id:"color",type:"color",def:"#000000ff",blurb:"Color of paint to use for stroking.",nick:"Color"},{id:"width",type:"number",range:{min:0,max:200},def:2,blurb:"The width of the brush used to stroke the path.",nick:"Width"},{id:"opacity",type:"number",range:{min:-2,max:2},def:1,blurb:"Opacity of stroke, note, does not behave like SVG since at the moment stroking is done using an airbrush tool.",nick:"Opacity"},{id:"transform",type:"string",def:"",blurb:"svg style description of transform.",nick:"Transform"},{id:"d",type:"GeglPath",def:"",blurb:"A GeglVector representing the path of the stroke",nick:"Vector"}]},{name:"gegl:video-degradation",title:"Video Degradation",description:"This function simulates the degradation of being on an old low-dotpitch RGB video monitor.",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"pattern",type:"enum",elements:[{label:"Staggered",value:"staggered"},{label:"Large staggered",value:"large-staggered"},{label:"Striped",value:"striped"},{label:"Wide striped",value:"wide-striped"},{label:"Long staggered",value:"long-staggered"},{label:"3x3",value:"3x3"},{label:"Large 3x3",value:"large-3x3"},{label:"Hex",value:"hex"}],def:"striped",blurb:"Type of RGB pattern to use",nick:"Pattern"},{id:"additive",type:"boolean",def:!0,blurb:"Whether the function adds the result to the original image.",nick:"Additive"},{id:"rotated",type:"boolean",def:!1,blurb:"Whether to rotate the RGB pattern by ninety degrees.",nick:"Rotated"}]},{name:"gegl:vignette",title:"Vignette",description:"Applies a vignette to an image. Simulates the luminance fall off at the edge of exposed film, and some other fuzzier border effects that can naturally occur with analog photography",categories:"render:light",inputs:["input"],outputs:["output"],properties:[{id:"shape",type:"enum",elements:[{label:"Circle",value:"circle"},{label:"Square",value:"square"}],def:"circle",blurb:null,nick:"Vignette shape"},{id:"color",type:"color",def:"#000000ff",blurb:"Defaults to 'black', you can use transparency here to erase portions of an image",nick:"Color"},{id:"radius",type:"number",range:{min:0,max:3},def:1.2,blurb:"How far out vignetting goes as portion of half image diagonal",nick:"Radius"},{id:"softness",type:"number",range:{min:0,max:1},def:.8,blurb:null,nick:"Softness"},{id:"gamma",type:"number",range:{min:0,max:10},def:2,blurb:"Falloff linearity",nick:"Gamma"},{id:"proportion",type:"number",range:{min:0,max:1},def:1,blurb:"How close we are to image proportions",nick:"Proportion"},{id:"squeeze",type:"number",range:{min:-1,max:1},def:0,blurb:"Aspect ratio to use, -0.5 = 1:2, 0.0 = 1:1, 0.5 = 2:1, -1.0 = 1:inf 1.0 = inf:1, this is applied after proportion is taken into account, to directly use squeeze factor as proportions, set proportion to 0.0.",nick:"Squeeze"},{id:"x",type:"number",def:.5,blurb:null,nick:"Center X"},{id:"y",type:"number",def:.5,blurb:null,nick:"Center Y"},{id:"rotation",type:"number",range:{min:0,max:360},def:0,blurb:null,nick:"Rotation"}]},{name:"gegl:warp",title:"Warp",description:"Compute a relative displacement mapping from a stroke",categories:"transform",inputs:["input"],outputs:["output"],properties:[{id:"strength",type:"number",range:{min:0,max:100},def:50,blurb:null,nick:"Strength"},{id:"size",type:"number",range:{min:1,max:1e4},def:40,blurb:null,nick:"Size"},{id:"hardness",type:"number",range:{min:0,max:1},def:.5,blurb:null,nick:"Hardness"},{id:"spacing",type:"number",range:{min:0,max:100},def:.01,blurb:null,nick:"Spacing"},{id:"stroke",type:"GeglPath",def:.01,blurb:null,nick:"Stroke"},{id:"behavior",type:"enum",elements:[{label:"Move pixels",value:"move"},{label:"Grow area",value:"grow"},{label:"Shrink area",value:"shrink"},{label:"Swirl clockwise",value:"swirl-cw"},{label:"Swirl counter-clockwise",value:"swirl-ccw"},{label:"Erase warping",value:"erase"}],def:"move",blurb:"Behavior of the op",nick:"Behavior"}]},{name:"gegl:waterpixels",title:"Waterpixels",description:"Superpixels based on the watershed transformation",categories:"segmentation",inputs:["input"],outputs:["output"],properties:[{id:"size",type:"int",range:{min:8},def:32,blurb:null,nick:"Superpixels size"},{id:"smoothness",type:"number",range:{min:0,max:1e3},def:1,blurb:null,nick:"Gradient smoothness"},{id:"regularization",type:"int",range:{min:0,max:50},def:0,blurb:"trade-off between superpixel regularity and adherence to object boundaries",nick:"Spatial regularization"},{id:"fill",type:"enum",elements:[{label:"Average",value:"average"}],def:"average",blurb:"How to fill superpixels",nick:"Superpixels color"}]},{name:"gegl:watershed-transform",title:"Watershed Transform",description:'Labels propagation by watershed transformation. Output buffer will keep the input format. Unlabelled pixels are marked with a given flag value (by default: last component with NULL value). The aux buffer is a "Y u8" image representing the priority levels (lower value is higher priority). If aux is absent, all labellized pixels have the same priority and propagated labels have a lower priority.',categories:"hidden",inputs:["aux","input"],outputs:["output"],properties:[{id:"flag-component",type:"int",def:-1,blurb:"Index of component flagging unlabelled pixels",nick:"Index of component flagging unlabelled pixels"},{id:"flag",type:"gpointer",def:-1,blurb:"Pointer to flag value for unlabelled pixels",nick:"flag"}]},{name:"gegl:wavelet-blur",title:"Wavelet Blur",description:"This blur is used for the wavelet decomposition filter, each pixel is computed from another by the HAT transform",categories:"blur",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"number",range:{min:0,max:1500},def:1,blurb:"Radius of the wavelet blur",nick:"Radius"}]},{name:"gegl:wavelet-blur-1d",title:"1D Wavelet-blur",description:"This blur is used for the wavelet decomposition filter, each pixel is computed from another by the HAT transform",categories:"hidden:blur",inputs:["input"],outputs:["output"],properties:[{id:"radius",type:"number",range:{min:0,max:1500},def:1,blurb:"Radius of the wavelet blur",nick:"Radius"},{id:"orientation",type:"enum",elements:[{label:"Horizontal",value:"horizontal"}],def:"horizontal",blurb:"The orientation of the blur - hor/ver",nick:"Orientation"}]},{name:"gegl:waves",title:"Waves",description:"Distort the image with waves",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"x",type:"number",def:.5,blurb:null,nick:"Center X"},{id:"y",type:"number",def:.5,blurb:null,nick:"Center Y"},{id:"amplitude",type:"number",range:{min:0,max:1e3},def:25,blurb:"Amplitude of the ripple",nick:"Amplitude"},{id:"period",type:"number",range:{min:.1,max:1e3},def:100,blurb:"Period (wavelength) of the ripple",nick:"Period"},{id:"phi",type:"number",range:{min:-1,max:1},def:0,blurb:null,nick:"Phase shift"},{id:"aspect",type:"number",range:{min:.1,max:10},def:1,blurb:null,nick:"Aspect ratio"},{id:"sampler-type",type:"enum",elements:[{label:"Nearest",value:"nearest"},{label:"Linear",value:"linear"},{label:"Cubic",value:"cubic"},{label:"NoHalo",value:"nohalo"}],def:"cubic",blurb:"Mathematical method for reconstructing pixel values",nick:"Resampling method"},{id:"clamp",type:"boolean",def:!1,blurb:"Limit deformation in the image area.",nick:"Clamp deformation"}]},{name:"gegl:webp-load",title:"WebP File Loader",description:"WebP image loader.",categories:"hidden",inputs:[],outputs:["output"],properties:[{id:"path",type:"string",def:"",blurb:"Path of file to load",nick:"File"},{id:"uri",type:"string",def:"",blurb:"URI for file to load",nick:"URI"}]},{name:"gegl:webp-save",title:"WebP File Saver",description:"WebP image saver",categories:"output",inputs:["input"],outputs:[],properties:[{id:"path",type:"string",def:"",blurb:"Target path and filename, use '-' for stdout",nick:"File"},{id:"quality",type:"int",range:{min:1,max:100},def:90,blurb:"WebP compression quality",nick:"Quality"}]},{name:"gegl:weighted-blend",title:"Weighted Blend",description:"blend two images using alpha values as weights",categories:"compositors:blend",inputs:["aux","input"],outputs:["output"],properties:[]},{name:"gegl:whirl-pinch",title:"Whirl Pinch",description:"Distort an image by whirling and pinching",categories:"distort:map",inputs:["input"],outputs:["output"],properties:[{id:"whirl",type:"number",def:90,blurb:"Whirl angle (degrees)",nick:"Whirl"},{id:"pinch",type:"number",range:{min:-1,max:1},def:0,blurb:"Pinch amount",nick:"Pinch"},{id:"radius",type:"number",range:{min:0,max:2},def:1,blurb:"Radius (1.0 is the largest circle that fits in the image, and 2.0 goes all the way to the corners)",nick:"Radius"}]},{name:"gegl:wind",title:"Wind",description:"Wind-like bleed effect",categories:"distort",inputs:["input"],outputs:["output"],properties:[{id:"style",type:"enum",elements:[{label:"Wind",value:"wind"}],def:"wind",blurb:"Style of effect",nick:"Style"},{id:"direction",type:"enum",elements:[{label:"Left",value:"left"},{label:"Right",value:"right"},{label:"Top",value:"top"}],def:"left",blurb:"Direction of the effect",nick:"Direction"},{id:"edge",type:"enum",elements:[{label:"Both",value:"both"},{label:"Leading",value:"leading"}],def:"leading",blurb:"Edge behavior",nick:"Edge Affected"},{id:"threshold",type:"int",range:{min:0,max:50},def:10,blurb:"Higher values restrict the effect to fewer areas of the image",nick:"Threshold"},{id:"strength",type:"int",range:{min:1,max:100},def:10,blurb:"Higher values increase the magnitude of the effect",nick:"Strength"},{id:"seed",type:"int",def:0,blurb:null,nick:"Random seed"}]},{name:"gegl:write-buffer",title:"Write Buffer",description:"Write input data into an existing GEGL buffer destination surface.",categories:"programming:output",inputs:["input"],outputs:[],properties:[{id:"buffer",type:"GeglBuffer",def:0,blurb:"A pre-existing GeglBuffer to write incoming buffer data to.",nick:"Buffer location"}]},{name:"svg:clear",title:"Clear",description:"Porter Duff operation clear (d = 0.0f)",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:color-burn",title:"Color-burn",description:"SVG blend operation color-burn (<code>if cA * aB + cB * aA <= aA * aB: d = cA * (1 - aB) + cB * (1 - aA) otherwise: d = (cA == 0 ? 1 : (aA * (cA * aB + cB * aA - aA * aB) / cA) + cA * (1 - aB) + cB * (1 - aA))</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:color-dodge",title:"Color-dodge",description:"SVG blend operation color-dodge (<code>if cA * aB + cB * aA >= aA * aB: d = aA * aB + cA * (1 - aB) + cB * (1 - aA) otherwise: d = (cA == aA ? 1 : cB * aA / (aA == 0 ? 1 : 1 - cA / aA)) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:darken",title:null,description:"SVG blend operation darken (<code>d = MIN (cA * aB, cB * aA) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:difference",title:null,description:"SVG blend operation difference (<code>d = cA + cB - 2 * (MIN (cA * aB, cB * aA))</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:dst",title:"Dst",description:"Porter Duff operation dst (d = cB)",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:dst-atop",title:"Dst-atop",description:"Porter Duff operation dst-atop (d = cB * aA + cA * (1.0f - aB))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:dst-in",title:"Dst-in",description:"Porter Duff operation dst-in (d = cB * aA)",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:dst-out",title:"Dst-out",description:"Porter Duff operation dst-out (d = cB * (1.0f - aA))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:dst-over",title:"Dst-over",description:"Porter Duff operation dst-over (d = cB + cA * (1.0f - aB))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:exclusion",title:null,description:"SVG blend operation exclusion (<code>d = (cA * aB + cB * aA - 2 * cA * cB) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:hard-light",title:"Hard-light",description:"SVG blend operation hard-light (<code>if 2 * cA < aA: d = 2 * cA * cB + cA * (1 - aB) + cB * (1 - aA) otherwise: d = aA * aB - 2 * (aB - cB) * (aA - cA) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:lighten",title:null,description:"SVG blend operation lighten (<code>d = MAX (cA * aB, cB * aA) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:overlay",title:"Overlay",description:"SVG blend operation overlay (<code>if 2 * cB > aB: d = 2 * cA * cB + cA * (1 - aB) + cB * (1 - aA) otherwise: d = aA * aB - 2 * (aB - cB) * (aA - cA) + cA * (1 - aB) + cB * (1 - aA)</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:plus",title:"Plus",description:"SVG blend operation plus (<code>d = cA + cB</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:screen",title:null,description:"SVG blend operation screen (<code>d = cA + cB - cA * cB</code>)",categories:"compositors:svgfilter",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:src",title:"Src",description:"Porter Duff operation src (d = cA)",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:src-atop",title:"Src-atop",description:"Porter Duff operation src-atop (d = cA * aB + cB * (1.0f - aA))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:src-in",title:"Src-in",description:"Porter Duff compositing operation src-in (formula:   cA * aB)",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:src-out",title:"Src-out",description:"Porter Duff operation src-out (d = cA * (1.0f - aB))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:src-over",title:"Normal compositing",description:"Porter Duff operation over (also known as normal mode, and src-over) (d = cA + cB * (1 - aA))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]},{name:"svg:xor",title:"Xor",description:"Porter Duff operation xor (d = cA * (1.0f - aB)+ cB * (1.0f - aA))",categories:"compositors:porter-duff",inputs:["aux","input"],outputs:["output"],properties:[{id:"srgb",type:"boolean",def:!1,blurb:"Use sRGB gamma instead of linear",nick:"sRGB"}]}];var Pe;!function(e){e.COLOR="color",e.IMAGE="image"}(Pe||(Pe={}));const Be={type:e.CommonValueType.BOOLEAN},Ae={type:e.CommonValueType.REAL},Me={type:e.CommonValueType.INTEGER},Oe={type:e.CommonValueType.STRING},Le={type:Pe.IMAGE},Ge={type:Pe.COLOR,converter:{deserialize:e=>function(e){function t(t){return parseInt(e.substring(2*t+1,2*t+3),16)}return e.startsWith("#")&&e.length>=7?{r:t(0),g:t(1),b:t(2)}:{r:0,g:0,b:0}}(e),serialize:e=>function(e){function t(e){const t="0"+e.toString(16);return t.substring(t.length-2,t.length)}return`#${t(e.r)}${t(e.g)}${t(e.b)}`}(e)}};function ze(e,t){return e||t}function Ne(e,t){return e.map(e=>({type:t,id:e,label:e,linkable:!0,editable:!1,valueType:Le}))}function Ie(t){return t.map(t=>{const i=function(t){return"number"==t.type?t.range?Object.assign(Object.assign({},Ae),{range:{min:t.range.min,max:t.range.max}}):Ae:"int"==t.type?t.range?Object.assign(Object.assign({},Me),{range:{min:t.range.min,max:t.range.max}}):Me:"boolean"==t.type?Be:"string"==t.type?Oe:"enum"==t.type?{type:e.CommonValueType.ENUM,enumValues:t.elements.map(e=>({name:e.value,label:e.label}))}:"color"==t.type?Ge:Le}(t);return{type:e.PropertyType.INPUT,id:t.id,label:ze(t.nick,t.id),linkable:!1,editable:!0,valueType:i,defaultValue:(n=i,r=t.def,r&&n.converter?n.converter.deserialize(r):r)};var n,r})}function He(e){if("gegl:png-load"===e.name||"gegl:png-save"===e.name)return!0}const Ve={handlerMouseDown(e,t,i){const n=e.openSelector(i.globalBounds().bottomLeft(),"select-color",{value:i.property.value});return n.result.then(t=>{e.emit(new M(i.property,t))},()=>{}),n.state},layout(e,i){const n=e.context.measureText(i.property.definition.label);i.bounds=new t(0,0).rect(n.width+11.5*e.style.unit,4*e.style.unit)},draw(e,t){const i=t.globalBounds(),n=e.style;e.drawText(i.origin.offset(3.5*n.unit,3*n.unit),o(e.theme.TEXT_COLOR),t.property.definition.label);const r=i.topRight().offset(-6*n.unit,0).rect(4*n.unit,4*n.unit);e.roundBox().filled(o(t.property.value)).draw(r)}},De=Ee.map(t=>({id:t.name,label:ze(t.title,t.name),categories:t.categories,properties:Ne(t.inputs,e.PropertyType.INPUT).concat(Ne(t.outputs,e.PropertyType.OUTPUT)).concat(Ie(t.properties)),preview:He(t)}));e.AddNodeCommand=B,e.AddNodeState=J,e.AllCorner=l,e.ChangePropertyValueCommand=M,e.ColorSelector=class extends xe{constructor(){super(),this.color={h:0,s:0,v:0},this.hueSelectElement=document.createElement("canvas"),this.hueSelectElement.width=200,this.hueSelectElement.height=50,this.hueSelectElement.addEventListener("click",e=>this.selectHue(e)),this.hueSelectElement.classList.add("hue"),this.selectorEl.appendChild(this.hueSelectElement),this.lightSelectElement=document.createElement("canvas"),this.lightSelectElement.width=200,this.lightSelectElement.height=200,this.lightSelectElement.addEventListener("click",e=>this.selectSaturationLightness(e)),this.lightSelectElement.classList.add("light"),this.selectorEl.appendChild(this.lightSelectElement),this.resultElement=document.createElement("div"),this.resultElement.addEventListener("click",e=>this.selectColor()),this.resultElement.classList.add("color-selection"),this.selectorEl.appendChild(this.resultElement),this.hueContext=this.hueSelectElement.getContext("2d"),this.lightContext=this.lightSelectElement.getContext("2d")}internalOpen(e,t){const{value:i}=t;return this.color=function({r:e,g:t,b:i}){const n=e/255,r=t/255,o=i/255,a=Math.max(n,r,o),s=a-Math.min(n,r,o);let l=0;return l=0==s?0:a==n?(r-o)/s%6:a==r?(o-n)/s+2:(n-r)/s+4,l*=60,{h:l,s:a>0?s/a:0,v:a}}(i),this.draw(),new Promise((e,t)=>{this.resolve=e,this.reject=t})}selectColor(){super.close(),this.resolve(Re(this.color.h,this.color.s,this.color.v))}close(){super.close(),this.reject()}draw(){this.resultElement.style.backgroundColor=o(Re(this.color.h,this.color.s,this.color.v));for(let e=0;e<200;++e)this.hueContext.fillStyle=o(Re(360*e/200,1,1)),this.hueContext.beginPath(),this.hueContext.rect(e,0,1,50),this.hueContext.fill();for(let e=0;e<200;++e)for(let t=0;t<200;++t)this.lightContext.fillStyle=o(Re(this.color.h,t/200,1-e/200)),this.lightContext.beginPath(),this.lightContext.rect(t,e,1,1),this.lightContext.fill()}selectHue(e){const t=e.target.getBoundingClientRect();this.color=Object.assign(Object.assign({},this.color),{h:Math.min(360,Math.max(0,360*(e.clientX-t.left)/t.width))}),this.draw()}selectSaturationLightness(e){const t=e.target.getBoundingClientRect();this.color=Object.assign(Object.assign({},this.color),{s:Math.min(1,Math.max(0,(e.clientX-t.left)/t.width)),v:Math.min(1,Math.max(0,1-(e.clientY-t.top)/t.height))}),this.draw()}},e.CompositeCommand=T,e.ConnectionView=me,e.CreateConnectionCommand=E,e.DeleteNodesCommand=A,e.Dimension=i,e.Framable=x,e.GeglGraphicalHelper=class{getHeaderColor(e){return e.definition.categories&&e.definition.categories.startsWith("programming:")?{r:252,g:131,b:71}:!e.definition.categories||"hidden"!==e.definition.categories&&"output"!==e.definition.categories?"gegl:add"==e.definition.id?{r:117,g:87,b:182}:{r:0,g:169,b:106}:{r:170,g:38,b:49}}getConnectorColor(e){return e.definition.valueType.type==Pe.IMAGE?{r:199,g:199,b:41}:{r:161,g:161,b:161}}getPropertyHandler(e){return e.definition.valueType.type==Pe.COLOR?Ve:he(e)}},e.GraphEditor=class{constructor(e){this.selectors=new Map,this.debug=!1,this.commandStack=new we,this.zoomState=new b,this.state=new V,this.mousePosition=new t(0,0),this.feedbacks=[],this.actions=new Map,this.selection=[],this.nodeGroup={nodes:[],frames:[]},this.nodeViews=[],this.frameViews=[],this.keymap=[],this.listeners=[],this.createDomElements(e),this.registerSelector("select-value",new ve),this.registerSelector("select-tree",new ke);const n=e.theme||r,o=this.parentElement.getBoundingClientRect();this.nodeFactory=e.nodeFactory,this.context=this.canvas.getContext("2d",{alpha:!1}),this.renderer=new g(this.context,new i(o.width,o.height),n,e.graphicalHelper),this.commandStack.addListener(this),this.registerActions(),this.registerKeymaps(),setTimeout(()=>{this.handleResize()},10)}onStackChange(e){this.listeners.forEach(e=>{e(this.nodeGroup)})}onGraphChange(e){this.listeners.push(e)}registerSelector(e,t){this.selectors.set(e,t),this.parentElement.appendChild(t.el())}updatePreviews(e){this.nodeViews.forEach(t=>{t.node.definition.preview&&e[t.node.id]&&t.updatePreview(e[t.node.id])}),this.draw()}registerActions(){this.registerAction("undo",()=>(this.commandStack.undo(),this.draw(),this.state)),this.registerAction("redo",()=>(this.commandStack.redo(),this.draw(),this.state)),this.registerAction("select-all",()=>(this.select(this.nodeViews,e.SelectionMode.REPLACE),this.draw(),this.state)),this.registerAction("create-node",()=>{const t=this.openSelector(this.mousePosition,"select-tree",{nodes:Q(this.nodeFactory.getNodeDefinitions())});return t.result.then(t=>{const i=this.nodeFactory.createNode(t.name,this.mousePosition),n=new ge(i);n.layoutNode(this.renderer),this.select([],e.SelectionMode.REPLACE),this.state=new J(this,n)},()=>{}),t.state}),this.registerAction("toggle-debug",()=>(this.debug=!this.debug,this.draw(),this.state)),this.registerAction("delete-node",()=>{if(this.selection.length>0){const e=this.selection.filter(e=>e.frame).map(e=>e.frame),t=fe(this.selection).map(e=>e.node);this.selection=[],this.emit(new A(this.nodeGroup,t.concat(),e))}return this.state}),this.registerAction("join-in-new-frame",()=>{if(this.selection.length>0){const t=fe(this.selection).map(e=>e.node);this.select([],e.SelectionMode.REPLACE),this.emit(new L(this.nodeGroup,t))}return this.state}),this.registerAction("add-to-frame",()=>(this.selection.length>0&&console.log("ADD TO FRAME",this.selection),this.state)),this.registerAction("remove-from-frame",()=>{const t=fe(this.selection).filter(e=>null!=e.parent).map(e=>e.node);return t.length>0&&(this.select([],e.SelectionMode.REPLACE),this.emit(new G(t))),this.state})}registerAction(e,t){this.actions.set(e,t)}doAction(e){const t=this.actions.get(e);return t?t():(console.log("Unknown action",e),this.state)}registerKeymaps(){this.registerKeymap("ctrl z","undo"),this.registerKeymap("ctrl y","redo"),this.registerKeymap("shift B","select-all"),this.registerKeymap("shift A","create-node"),this.registerKeymap("shift H","toggle-debug"),this.registerKeymap("Delete","delete-node"),this.registerKeymap("shift J","join-in-new-frame"),this.registerKeymap("shift P","add-to-frame"),this.registerKeymap("alt p","remove-from-frame")}registerKeymap(t,i){const n=function(t){let i=0,n="";return t.split(" ").forEach(t=>{"ctrl"===t?i|=e.ControlKey.CtrlKey:"alt"===t?i|=e.ControlKey.AltKey:"shift"===t?i|=e.ControlKey.ShiftKey:n=t}),{meta:i,key:n}}(t);this.keymap.push(Object.assign(Object.assign({},n),{action:i}))}createDomElements(e){this.parentElement=document.createElement("div"),this.parentElement.setAttribute("class","graph-editor-container"),e.container.appendChild(this.parentElement),this.eventElement=document.createElement("div"),this.eventElement.addEventListener("mousedown",e=>this.handleMouseDown(e)),this.eventElement.addEventListener("mouseup",e=>this.handleMouseUp(e)),this.eventElement.addEventListener("mousemove",e=>this.handleMouseMove(e)),this.eventElement.addEventListener("wheel",e=>this.handleMouseWheel(e)),this.parentElement.appendChild(this.eventElement),this.canvas=document.createElement("canvas"),this.eventElement.appendChild(this.canvas),window.addEventListener("resize",e=>this.handleResize()),window.addEventListener("keyup",e=>this.handleKeyUp(e))}handleResize(){const e=this.parentElement.getBoundingClientRect();this.canvas.width=e.width,this.canvas.height=e.height,setTimeout(()=>{this.renderer.setSize(new i(e.width,e.height)),this.draw()},10)}handleMouseDown(e){const t=Te(e);this.state=this.state.handleMouseDown(this,this.scalePosition(t)),this.debugState("MOUSE DOWN")}handleMouseUp(e){const t=Te(e);this.state=this.state.handleMouseUp(this,this.scalePosition(t)),this.debugState("MOUSE UP")}handleMouseMove(e){const t=Te(e);this.mousePosition=t.position,this.state=this.state.handleMouseMove(this,this.scalePosition(t)),this.debugState("MOUSE MOVE")}handleMouseWheel(e){const t=Te(e);this.state=this.state.handleMouseWheel(this,this.scalePosition(t)),this.debugState("MOUSE WHEEL")}handleKeyUp(e){const t=Te(e);this.state=this.state.handleKeyUp(this,t),this.debugState("KEY")}syncView(){const e=new Map,t=new Map;this.nodeViews.forEach(t=>{e.set(t.node,t),t.parent=null}),this.frameViews.forEach(e=>{t.set(e.frame,e),e.parent=null}),this.nodeViews=this.nodeGroup.nodes.map(t=>{const i=e.get(t);return i||new ge(t)}),this.frameViews=this.nodeGroup.frames.map(e=>{const i=t.get(e);return i||new ye(e)});const i=new Map;this.nodeViews.forEach(e=>{e.propertyViews.forEach(e=>i.set(e.property,e))});const n=new Map;this.nodeViews.forEach(e=>{n.set(e.node,e)}),this.frameViews.forEach(e=>{n.set(e.frame,e)}),this.nodeViews.forEach(e=>e.updateConnections(i)),this.frameViews.forEach(e=>e.updateChildren(n))}draw(){this.renderer.context.save(),this.renderer.clearScreen(this.renderer.theme.BACKGROUND_COLOR),this.renderer.setProjection(this.zoomState),this.renderer.drawGrid(this.zoomState,this.renderer.theme.BORDER_COLOR,this.renderer.style.snapSize,5,2),this.syncView(),this.nodeViews.forEach(e=>e.layoutNode(this.renderer)),this.frameViews.filter(e=>!e.parent).forEach(e=>e.draw(this)),this.nodeViews.forEach(t=>{t.propertyViews.filter(t=>t.property.definition.type==e.PropertyType.OUTPUT).forEach(e=>{e.connections.forEach(e=>{const t=e.from.globalPosition(),i=e.to.globalPosition(),n=this.isSelected(e.from.node)||this.isSelected(e.to.node);this.renderer.drawConnection(t,i,n?this.renderer.theme.SELECTION_COLOR:this.renderer.theme.NODE_BACK_COLOR)})})}),this.feedbacks.filter(e=>!e.foreground).forEach(e=>e.draw(this)),this.nodeViews.forEach(e=>e.draw(this)),this.feedbacks.filter(e=>e.foreground).forEach(e=>e.draw(this)),this.renderer.context.restore()}addFeedback(e){this.feedbacks.push(e)}removeFeedback(e){this.feedbacks.splice(this.feedbacks.indexOf(e),1)}setNodeGroup(e){this.nodeGroup=e,this.reset(),this.draw()}reset(){this.selection=[],this.feedbacks=[],this.commandStack.clear(),this.zoomState.reset()}emit(e){this.commandStack.emit(e),this.draw()}load(e){this.reset();const t=this.nodeFactory.load(e);this.nodeGroup=t,t.zoomState&&this.zoomState.update(t.zoomState.origin,t.zoomState.scale),this.nodeGroup.zoomState=this.zoomState,this.draw(),this.onStackChange(!1)}save(){return this.nodeGroup.zoomState=this.zoomState,this.nodeFactory.save(this.nodeGroup)}updateZoom(e,t){this.zoomState.update(this.zoomState.origin.sub(e),this.zoomState.scale/t),this.draw()}updatePosition(e){this.zoomState.move(e),this.draw()}isSelected(e){return this.selection.indexOf(e)>=0}select(t,i){this.selection.forEach(e=>e.isSelected=!1),i==e.SelectionMode.ADD?t.forEach(e=>{this.selection.indexOf(e)<0&&this.selection.push(e)}):i==e.SelectionMode.REMOVE?t.forEach(e=>{const t=this.selection.indexOf(e);t>=0&&this.selection.splice(t,1)}):this.selection=t,this.selection.forEach(e=>e.isSelected=!0)}canConnect(t,i){return t.node!=i.node&&t.definition.type!=i.definition.type&&!(t.definition.type==e.PropertyType.INPUT&&t.isConnected()||i.definition.type==e.PropertyType.INPUT&&i.isConnected())}openSelector(e,t,i){const n=this.getScreenPosition(e),r=this.selectors.get(t),o=r?r.open(n,i):null;return o?{state:new Se,result:o.finally(()=>{this.state=new V})}:(console.log("Unknown selector",t,i),{state:new V,result:Promise.reject()})}scalePosition(e){return e.screenPosition=e.position,e.position=this.renderer.getPosition(this.zoomState,e.position),e}getScreenPosition(e){return new t((e.x-this.zoomState.origin.x)*this.zoomState.scale,(e.y-this.zoomState.origin.y)*this.zoomState.scale)}debugState(e){if(this.debug){let i=new t(10,this.renderer.size.height-20);this.renderer.roundBox().filled(o(this.renderer.theme.PROPERTY_COLOR)).draw(i.offset(0,3*-this.renderer.style.unit).rect(400,4*this.renderer.style.unit)),this.renderer.drawText(i.offset(10,0),o(this.renderer.theme.TEXT_COLOR),e+" - "+this.state.constructor.name);const n=5;i=new t(this.renderer.size.width-10,this.renderer.size.height-20),this.renderer.roundBox().filled(o(this.renderer.theme.PROPERTY_COLOR)).draw(i.offset(-400,-this.renderer.style.unit*(4*n-1)).rect(400,4*this.renderer.style.unit*n));for(let e=0;e<Math.min(n,this.commandStack.commands.length);++e){const t=this.commandStack.commands[this.commandStack.commands.length-1-e],r=this.commandStack.undoIndex==this.commandStack.commands.length-1-e;this.renderer.drawText(i.offset(-390,4*this.renderer.style.unit*(e-n+1)),o(this.renderer.theme.TEXT_COLOR),(r?"*":" ")+t.constructor.name)}}}},e.IdleState=V,e.JoinInNewFrameCommand=L,e.MoveNodeCommand=S,e.Node=v,e.NodeConnection=w,e.NodeFactory=class{constructor(e){this.nodeDefinitions=e,this.nodeDefinitionByType={},e.forEach(e=>{this.nodeDefinitionByType[e.id]=e})}getNodeDefinitions(){return this.nodeDefinitions}createNode(e,t){const i=this.nodeDefinitionByType[e];if(!i)throw new Error("unknown node type "+e);return new v(this.newId(),i,t)}newId(){const e="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";let t="";for(let i=0;i<16;++i)t+=e[Math.floor(Math.random()*e.length)];return t}load(e){const i=new Map,n=e.nodes.map(e=>{const n=new v(e.id,this.nodeDefinitionByType[e.type],new t(e.location.x,e.location.y));if(n.collapsed=e.collapsed||!1,n.fullWidth=e.fullWidth||0,e.properties)for(let t in e.properties){const i=e.properties[t];n.findProperty(t).value=i}return i.set(n.id,n),n});e.connections.forEach(e=>{const t=i.get(e.from.node).findProperty(e.from.property),n=i.get(e.to.node).findProperty(e.to.property);new w(t,n).connect()});const r=new b;return e.canvas&&r.update(new t(e.canvas.position.x||0,e.canvas.position.y||0),e.canvas.zoom||1),{nodes:n,frames:[],zoomState:r}}save(t){const i=[];return{nodes:t.nodes.map(t=>{const n={};let r=!1;t.properties.forEach(t=>{void 0!==t.value&&(n[t.definition.id]=t.value,r=!0),t.definition.type===e.PropertyType.OUTPUT&&t.connections&&t.connections.forEach(e=>{i.push({from:{node:e.from.node.id,property:e.from.definition.id},to:{node:e.to.node.id,property:e.to.definition.id}})})});const o={id:t.id,type:t.definition.id,location:{x:t.location.x,y:t.location.y}};return t.collapsed&&(o.collapsed=!0),t.fullWidth>0&&(o.fullWidth=t.fullWidth),r&&(o.properties=n),o}),connections:i,canvas:{position:{x:t.zoomState.origin.x,y:t.zoomState.origin.y},zoom:t.zoomState.scale}}}},e.NodeFrame=C,e.NodeFrameView=ye,e.NodeProperty=k,e.NodePropertyView=be,e.NodeView=ge,e.Point=t,e.Rectangle=n,e.RemoveConnectionCommand=P,e.RemoveFromFrameCommand=G,e.RenameFrameCommand=z,e.Renderer=g,e.ResizeNodeCommand=O,e.RoundBox=f,e.State=y,e.ToggleCollapseCommand=R,e.ZoomState=b,e.booleanHandler=pe,e.darkTheme=r,e.defaultPropertyHandler=ce,e.enumHandler=le,e.geglNodeDefinitions=De,e.getAllNodesFromSelection=fe,e.getDefaultPropertyHandler=he,e.lightTheme={BACKGROUND_COLOR:{r:255,g:255,b:255},NODE_BACK_COLOR:{r:133,g:133,b:133},FRAME_BACK_COLOR:{r:85,g:112,b:85},FRAME_COLOR_ALPHA:.9,TEXT_COLOR:{r:255,g:255,b:255},BORDER_COLOR:{r:0,g:0,b:0},PROPERTY_COLOR:{r:86,g:86,b:86},HIGHLIGHT_COLOR:{r:55,g:129,b:191},SELECT_BACK_COLOR:{r:39,g:39,b:39},CHECK_BACK_COLOR:{r:102,g:102,b:102},SELECTION_COLOR:{r:196,g:139,b:67}},e.numberHandler=ae,e.rgb=o,e.stringHandler=se,Object.defineProperty(e,"__esModule",{value:!0})}(t)},function(e,t,i){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var i=function(e,t){var i=e[1]||"",n=e[3];if(!n)return i;if(t&&"function"==typeof btoa){var r=(a=n,s=btoa(unescape(encodeURIComponent(JSON.stringify(a)))),l="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s),"/*# ".concat(l," */")),o=n.sources.map((function(e){return"/*# sourceURL=".concat(n.sourceRoot||"").concat(e," */")}));return[i].concat(o).concat([r]).join("\n")}var a,s,l;return[i].join("\n")}(t,e);return t[2]?"@media ".concat(t[2]," {").concat(i,"}"):i})).join("")},t.i=function(e,i,n){"string"==typeof e&&(e=[[null,e,""]]);var r={};if(n)for(var o=0;o<this.length;o++){var a=this[o][0];null!=a&&(r[a]=!0)}for(var s=0;s<e.length;s++){var l=[].concat(e[s]);n&&r[l[0]]||(i&&(l[2]?l[2]="".concat(i," and ").concat(l[2]):l[2]=i),t.push(l))}},t}},function(e,t,i){"use strict";var n,r=function(){return void 0===n&&(n=Boolean(window&&document&&document.all&&!window.atob)),n},o=function(){var e={};return function(t){if(void 0===e[t]){var i=document.querySelector(t);if(window.HTMLIFrameElement&&i instanceof window.HTMLIFrameElement)try{i=i.contentDocument.head}catch(e){i=null}e[t]=i}return e[t]}}(),a=[];function s(e){for(var t=-1,i=0;i<a.length;i++)if(a[i].identifier===e){t=i;break}return t}function l(e,t){for(var i={},n=[],r=0;r<e.length;r++){var o=e[r],l=t.base?o[0]+t.base:o[0],u=i[l]||0,d="".concat(l," ").concat(u);i[l]=u+1;var p=s(d),c={css:o[1],media:o[2],sourceMap:o[3]};-1!==p?(a[p].references++,a[p].updater(c)):a.push({identifier:d,updater:f(c,t),references:1}),n.push(d)}return n}function u(e){var t=document.createElement("style"),n=e.attributes||{};if(void 0===n.nonce){var r=i.nc;r&&(n.nonce=r)}if(Object.keys(n).forEach((function(e){t.setAttribute(e,n[e])})),"function"==typeof e.insert)e.insert(t);else{var a=o(e.insert||"head");if(!a)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");a.appendChild(t)}return t}var d,p=(d=[],function(e,t){return d[e]=t,d.filter(Boolean).join("\n")});function c(e,t,i,n){var r=i?"":n.media?"@media ".concat(n.media," {").concat(n.css,"}"):n.css;if(e.styleSheet)e.styleSheet.cssText=p(t,r);else{var o=document.createTextNode(r),a=e.childNodes;a[t]&&e.removeChild(a[t]),a.length?e.insertBefore(o,a[t]):e.appendChild(o)}}function h(e,t,i){var n=i.css,r=i.media,o=i.sourceMap;if(r?e.setAttribute("media",r):e.removeAttribute("media"),o&&btoa&&(n+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o))))," */")),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}var m=null,b=0;function f(e,t){var i,n,r;if(t.singleton){var o=b++;i=m||(m=u(t)),n=c.bind(null,i,o,!1),r=c.bind(null,i,o,!0)}else i=u(t),n=h.bind(null,i,t),r=function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(i)};return n(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;n(e=t)}else r()}}e.exports=function(e,t){(t=t||{}).singleton||"boolean"==typeof t.singleton||(t.singleton=r());var i=l(e=e||[],t);return function(e){if(e=e||[],"[object Array]"===Object.prototype.toString.call(e)){for(var n=0;n<i.length;n++){var r=s(i[n]);a[r].references--}for(var o=l(e,t),u=0;u<i.length;u++){var d=s(i[u]);0===a[d].references&&(a[d].updater(),a.splice(d,1))}i=o}}}},function(e,t,i){e.exports=i(24)},function(e,t,i){var n=i(2),r=i(5);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"\n.graph-editor-container {\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    font-family: Roboto;\n}\n\n.graph-editor-container canvas {\n    width: 100%;\n    height: 100%;\n}\n\n/* Selector */\n\n.selector-glass-pane {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 100;\n}\n\n.selector-glass-pane.hide {\n    display: none;\n}\n    \n.selector {\n    margin: 0;\n    padding: 10px;\n    position: fixed;\n    width: 200px;\n    border: 1px solid black;\n    border-radius: 10px;\n    color: white;\n    background-color: #555555;\n    filter: drop-shadow(5px 5px 5px black);\n}\n\n/* ValueSelector */\n\ninput.value-selector {\n    width: 100%;\n    border: 1px solid #999999;\n    background-color: #999999;\n    border-radius: 5px;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0.4em;\n    font-size: inherit;\n}\n\ninput.value-selector.error {\n    border: 1px solid red;\n}\n\ninput.value-selector:focus {\n    outline: none;\n}\n\n/* TreeSelector */\n\ninput.tree-selector {\n    width: 100%;\n    border: 0;\n    background-color: #999999;\n    border-radius: 5px;\n    box-sizing: border-box;\n    margin: 0 0 5px 0;\n    padding: 0.4em;\n    font-size: inherit;\n}\n\ninput.tree-selector:focus {\n    outline: none;\n}\n\nul.tree-selector {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    max-height: 300px;\n    overflow-y: auto;\n    overflow-x: hidden;\n}\n\nul.tree-selector li {\n    margin: 0;\n    padding: 5px;\n}\n\nul.tree-selector li.selected {\n    background-color: #3781bf;\n}\n\nul.tree-selector li:hover {\n    background-color: #4791cf;\n}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(7);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"canvas.hue {\n    width: 100%;\n    height: 50px;\n    padding-bottom: 10px;\n}\n\ncanvas.light {\n    width: 100%;\n    height: 200px;\n    padding-bottom: 10px;\n}\n\n.color-selection {\n    width: 100%;\n    height: 50px;\n}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(9);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"button.round.svelte-njfq9m{width:30px;height:30px;border:1px solid var(--border-color);border-radius:50%;background-color:var(--editor-color);outline:none;text-align:center;color:lightgray}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(11);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"pre.svelte-1qi2sn1{overflow:auto;width:100%;height:100%;background-color:var(--editor-color)}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(13);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"input.svelte-1lk0m5a{margin:10px}ul.svelte-1lk0m5a{margin:10px;list-style-type:none}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(15);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"div.main.svelte-qiruuj.svelte-qiruuj{width:100%;height:100%;position:relative}div.toolbar.svelte-qiruuj.svelte-qiruuj{position:absolute;bottom:10px;right:10px}div.toolbar.hide.svelte-qiruuj.svelte-qiruuj{display:none}.layer-selector.svelte-qiruuj ul.svelte-qiruuj{list-style-type:none}div.layer-selector.svelte-qiruuj.svelte-qiruuj{position:absolute;bottom:35px;right:0;border-radius:5px;border:1px solid var(--border-color);background-color:var(--editor-color);padding:10px}div.layer-selector.hide.svelte-qiruuj.svelte-qiruuj{display:none}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(17);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"p.svelte-cgc3zo{padding:10px}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(19);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,".container.svelte-bkw2mk.svelte-bkw2mk{position:fixed;bottom:0;right:0;width:33%;height:33%;z-index:100;background-color:var(--back-color);border:1px solid var(--border-color);--border-color:#565656;--back-color:#454545;--inactive-color:#656565;--editor-color:#808080;--header-height:42px}.container.collapsed.svelte-bkw2mk.svelte-bkw2mk{height:var(--header-height)}.container.fullscreen.svelte-bkw2mk.svelte-bkw2mk{height:100%;width:50%}header.svelte-bkw2mk.svelte-bkw2mk{display:flex;flex-direction:row;align-items:center;justify-content:space-between;height:var(--header-height);border-bottom:1px solid var(--border-color)}header.svelte-bkw2mk li.svelte-bkw2mk{display:inline-block;padding:10px;background-color:var(--inactive-color);border-right:1px solid var(--border-color);color:lightgray}li.active.svelte-bkw2mk.svelte-bkw2mk{color:black;background-color:var(--editor-color)}span.svelte-bkw2mk.svelte-bkw2mk{cursor:pointer}.content.svelte-bkw2mk.svelte-bkw2mk{height:calc(100% - var(--header-height));width:100%}.buttons.svelte-bkw2mk.svelte-bkw2mk{display:flex;flex-direction:row;align-items:center;padding:5px}.icon{padding-right:5px}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(21);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"div.editor.svelte-7hk7a9{width:100vw;height:100vh}",""]),t.default=r},function(e,t,i){var n=i(2),r=i(23);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[e.i,r,""]]);var o={insert:"head",singleton:!1};n(r,o);e.exports=r.locals||{}},function(e,t,i){"use strict";i.r(t);var n=i(1),r=i.n(n)()(!1);r.push([e.i,"html, body, *{padding:0;margin:0;font-family:Roboto}",""]),t.default=r},function(e,t,i){"use strict";function n(){}i.r(t);function r(e){return e()}function o(){return Object.create(null)}function a(e){e.forEach(r)}function s(e){return"function"==typeof e}function l(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function u(e){return 0===Object.keys(e).length}new Set;function d(e,t){e.appendChild(t)}function p(e,t,i){e.insertBefore(t,i||null)}function c(e){e.parentNode.removeChild(e)}function h(e,t){for(let i=0;i<e.length;i+=1)e[i]&&e[i].d(t)}function m(e){return document.createElement(e)}function b(e){return document.createElementNS("http://www.w3.org/2000/svg",e)}function f(e){return document.createTextNode(e)}function g(){return f(" ")}function y(e,t,i,n){return e.addEventListener(t,i,n),()=>e.removeEventListener(t,i,n)}function x(e,t,i){null==i?e.removeAttribute(t):e.getAttribute(t)!==i&&e.setAttribute(t,i)}function v(e,t){t=""+t,e.wholeText!==t&&(e.data=t)}function k(e,t,i){e.classList[i?"add":"remove"](t)}new Set;let w;function C(e){w=e}function T(){if(!w)throw new Error("Function called outside component initialization");return w}function S(e){T().$$.on_mount.push(e)}const R=[],E=[],P=[],B=[],A=Promise.resolve();let M=!1;function O(){M||(M=!0,A.then(N))}function L(e){P.push(e)}let G=!1;const z=new Set;function N(){if(!G){G=!0;do{for(let e=0;e<R.length;e+=1){const t=R[e];C(t),I(t.$$)}for(R.length=0;E.length;)E.pop()();for(let e=0;e<P.length;e+=1){const t=P[e];z.has(t)||(z.add(t),t())}P.length=0}while(R.length);for(;B.length;)B.pop()();M=!1,G=!1,z.clear()}}function I(e){if(null!==e.fragment){e.update(),a(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(L)}}const H=new Set;let V;function D(){V={r:0,c:[],p:V}}function F(){V.r||a(V.c),V=V.p}function U(e,t){e&&e.i&&(H.delete(e),e.i(t))}function _(e,t,i,n){if(e&&e.o){if(H.has(e))return;H.add(e),V.c.push(()=>{H.delete(e),n&&(i&&e.d(1),n())}),e.o(t)}}"undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;new Set(["allowfullscreen","allowpaymentrequest","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected"]);let $;function W(e){e&&e.c()}function X(e,t,i){const{fragment:n,on_mount:o,on_destroy:l,after_update:u}=e.$$;n&&n.m(t,i),L(()=>{const t=o.map(r).filter(s);l?l.push(...t):a(t),e.$$.on_mount=[]}),u.forEach(L)}function Y(e,t){const i=e.$$;null!==i.fragment&&(a(i.on_destroy),i.fragment&&i.fragment.d(t),i.on_destroy=i.fragment=null,i.ctx=[])}function j(e,t,i,r,s,l,u=[-1]){const d=w;C(e);const p=t.props||{},h=e.$$={fragment:null,ctx:null,props:l,update:n,not_equal:s,bound:o(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(d?d.$$.context:[]),callbacks:o(),dirty:u,skip_bound:!1};let m=!1;if(h.ctx=i?i(e,p,(t,i,...n)=>{const r=n.length?n[0]:i;return h.ctx&&s(h.ctx[t],h.ctx[t]=r)&&(!h.skip_bound&&h.bound[t]&&h.bound[t](r),m&&function(e,t){-1===e.$$.dirty[0]&&(R.push(e),O(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}(e,t)),i}):[],h.update(),m=!0,a(h.before_update),h.fragment=!!r&&r(h.ctx),t.target){if(t.hydrate){const e=(b=t.target,Array.from(b.childNodes));h.fragment&&h.fragment.l(e),e.forEach(c)}else h.fragment&&h.fragment.c();t.intro&&U(e.$$.fragment),X(e,t.target,t.anchor),N()}var b;C(d)}"function"==typeof HTMLElement&&($=class extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"})}connectedCallback(){for(const e in this.$$.slotted)this.appendChild(this.$$.slotted[e])}attributeChangedCallback(e,t,i){this[e]=i}$destroy(){Y(this,1),this.$destroy=n}$on(e,t){const i=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return i.push(t),()=>{const e=i.indexOf(t);-1!==e&&i.splice(e,1)}}$set(e){this.$$set&&!u(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}});class K{$destroy(){Y(this,1),this.$destroy=n}$on(e,t){const i=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return i.push(t),()=>{const e=i.indexOf(t);-1!==e&&i.splice(e,1)}}$set(e){this.$$set&&!u(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}var q=i(0);i(4),i(6);class Z{constructor(e,t){this.dx=e,this.dy=t}add(e){return new Z(this.dx+e.dx,this.dy+e.dy)}crossProduct(e){return this.dx*e.dy-this.dy*e.dx}}class J{constructor(e,t){this.x=e,this.y=t}min(e){return Q(Math.min(this.x,e.x),Math.min(this.y,e.y))}max(e){return Q(Math.max(this.x,e.x),Math.max(this.y,e.y))}move(e){return new J(this.x+e.dx,this.y+e.dy)}subtract(e){return new Z(this.x-e.x,this.y-e.y)}rect(e,t){return new te(this,new ee(e,t))}rectAtCorner(e){return new te(this,new ee(e.x-this.x,e.y-this.y))}}function Q(e,t){return new J(e,t)}class ee{constructor(e,t){this.width=e,this.height=t}}class te{constructor(e,t){this.x=e.x,this.y=e.y,this.width=t.width,this.height=t.height}unionPoint(e){return this.origin().min(e).rectAtCorner(this.corner().max(e))}union(e){return this.origin().min(e.origin()).rectAtCorner(this.corner().max(e.corner()))}containsPoint(e){return e.x>=this.x&&e.y>=this.y&&e.x<this.corner().x&&e.y<this.corner().y}containsRect(e){return this.containsPoint(e.origin())&&this.containsPoint(e.corner())}overlap(e){return e.origin().x<=this.corner().x&&e.origin().y<=this.corner().y&&e.corner().x>=this.origin().x&&e.corner().y>=this.origin().y}origin(){return Q(this.x,this.y)}corner(){return Q(this.x+this.width,this.y+this.height)}bottomLeft(){return new J(this.x,this.y+this.height)}topRight(){return new J(this.x+this.width,this.y)}area(){return this.width*this.height}}const ie=document.createElement("canvas").getContext("2d");class ne{constructor(e,t){this.min=e,this.max=t,this.total=0,this.values=new Array(t-e).fill(0)}add(e,t){this.values[e-this.min]+=t,this.total+=t}ile(e){const t=(i=e*this.total,n=1,r=this.total,Math.max(Math.min(i,r),n));var i,n,r;let o=0,a=0;for(;a<this.values.length&&o<t;)o+=this.values[a++];return a>0?this.min+a-(o-t)/this.values[a-1]:this.min}}class re{constructor(e){this.bounds=e,this.bxdim=Math.floor(e.width/16)+1,this.bydim=Math.floor(e.height/16)+1,this.cells=new Array(this.bxdim*this.bydim);for(let e=0;e<this.cells.length;++e)this.cells[e]=[]}get(e){const t=this.getCellCoords(e);return this.cells[this.bxdim*t.y+t.x]}getCellCoords(e){return Q(Math.floor((e.x-this.bounds.x)/16),Math.floor((e.y-this.bounds.y)/16))}fillWith(e,t){e.forEach(e=>{this.get(t(e)).push(e)})}forEach(e){this.cells.forEach(t=>{t.length>0&&e(t)})}forEachIn(e,t){const i=this.getCellCoords(e.origin()),n=this.getCellCoords(e.corner());for(let e=i.y;e<=n.y;++e)for(let r=i.x;r<=n.x;++r){const i=this.cells[this.bxdim*e+r];if(i.length>0&&!t(i))return}}}class oe{constructor(e){this.outlines=[],this.horzStrokeWidth=0,this.vertStrokeWidth=0,this.outlines.push(e),this.area=this.computeArea()}computeArea(){let e=0;return this.outlines.forEach(t=>{e+=t.area()}),e}boundingBox(){let e=null;return this.outlines.forEach(t=>{e=e?e.union(t.bounds):t.bounds}),e}setBlobStrokeWidth(e){const t=this.boundingBox(),i=new ne(0,256);for(let n=0;n<t.height;++n){let r=0,o=e.getPixel(t.x+0,t.y+n);for(let a=1;a<t.width;++a){const s=e.getPixel(t.x+a,t.y+n);!(r<o)||0!=n&&o!=e.getPixel(t.x+a-1,t.y+n-1)||n!=t.height-1&&o!=e.getPixel(t.x+a-1,t.y+n+1)||(o>s?i.add(2*o-1,1):o==s&&a+1<t.width&&o>e.getPixel(t.x+a+1,t.y+n)&&i.add(2*o,1)),r=o,o=s}}const n=new ne(0,256);for(let i=0;i<t.width;++i){let r=0,o=e.getPixel(t.x+i,t.y+0);for(let a=1;a<t.height;++a){const s=e.getPixel(t.x+i,t.y+a);!(r<o)||0!=i&&o!=e.getPixel(t.x+i-1,t.y+a-1)||i!=t.width-1&&o!=e.getPixel(t.x+i+1,t.y+a-1)||(o>s?n.add(2*o-1,1):o==s&&a+1<t.height&&o>e.getPixel(t.x+i,t.y+a+1)&&n.add(2*o,1)),r=o,o=s}}this.horzStrokeWidth=0,this.vertStrokeWidth=0,i.total>=(t.width+t.height)/4?(this.horzStrokeWidth=i.ile(.5),n.total>=(t.width+t.height)/4&&(this.vertStrokeWidth=n.ile(.5))):n.total>=(t.width+t.height)/4||n.total>i.total?this.vertStrokeWidth=n.ile(.5):i.total>2&&(this.horzStrokeWidth=i.ile(.5))}}function ae(e,t,i){return!(function e(t,i,n,r){if((r+=1)>5)return n+r;let o=0,a=0;return t.forEachIn(i.bounds,s=>{for(let l of s)if(l!=i&&l.isInside(i)){if(o+=1,o>10)return!1;const i=n-o-a;if(i>0&&(a+=10*e(t,l,i,r)),o+a>n)return!1}return!0}),o+a}(e,t,45,0)>45)&&(function(e,t,i){e.forEachIn(t.bounds,e=>{for(let n=0;n<e.length;){const r=e[n];r.isInside(t)?(e.splice(n,1),i.push(r)):++n}return!0})}(e,t,i),!0)}function se(e,t,i){const n=[];for(t.forEach(e=>{!function e(t,i){for(let n=0;n<i.length;++n){const r=i[n];if(r.isInside(t)){for(i.splice(n,1,t),t.children.push(r);++n<i.length;){const e=i[n];e.isInside(t)&&(i.splice(n,1),t.children.push(e))}return}if(t.isInside(r))return void e(t,r.children)}i.push(t)}(e,n)});n.length>0;){const t=n.shift();t.isLegallyNested()||(t.children.forEach(e=>n.push(e)),e=!1),e?i.blobs.push(new oe(t)):i.noises.push(new oe(t))}}const le=new class{constructor(){this.textord_max_noise_size=7,this.textord_noise_area_ratio=.7,this.textord_initialx_ile=.75,this.textord_initialasc_ile=.9,this.textord_width_limit=8,this.textord_min_linesize=1.25,this.textord_excess_blobsize=1.3}};class ue{constructor(e){this.bounds=e,this.blobs=[],this.noises=[],this.smalls=[],this.larges=[]}filterBlobs(){let e=this.blobs,t=this.noises,i=[],n=[],r=0,o=[];e.forEach(e=>{const n=e.boundingBox();n.height<le.textord_max_noise_size?t.push(e):e.area>=n.area()*le.textord_noise_area_ratio?i.push(e):(o.push(e),r=Math.max(r,n.height))}),e=o;let a=new ne(0,r+1);e.forEach(e=>a.add(e.boundingBox().height,1));let s=a.ile(le.textord_initialx_ile);const l=Math.ceil(1.25*s/.5),u=Math.floor(s/2),d=Math.ceil(s*le.textord_width_limit);o=[],i.forEach(t=>{const i=t.boundingBox().height;i>l?n.push(t):i>=u?e.push(t):o.push(t)}),i=o,a=new ne(0,r+1),o=[],e.forEach(e=>{const t=e.boundingBox().height,r=e.boundingBox().width;t<u?i.push(e):t>l||r>d?n.push(e):(o.push(e),a.add(t,1))}),e=o,this.blobs=e,this.noises=t,this.smalls=i,this.larges=n;const p=a.ile(le.textord_initialasc_ile)*(.5/.75);p>s&&(s=p),this.lineSize=s,0==this.lineSize&&(this.lineSize=1),this.lineSpacing=1.25*this.lineSize/.5,this.lineSize*=le.textord_min_linesize,this.maxBlobSize=this.lineSize*le.textord_excess_blobsize}}var de,pe;!function(e){e[e.COLOR=0]="COLOR",e[e.GRAYSCALE=1]="GRAYSCALE",e[e.BINARY=2]="BINARY"}(de||(de={})),function(e){e[e.BLACK=0]="BLACK",e[e.WHITE=255]="WHITE"}(pe||(pe={}));const ce=Number.MAX_SAFE_INTEGER;var he;!function(e){e[e.LEFT=0]="LEFT",e[e.UP=1]="UP",e[e.RIGHT=2]="RIGHT",e[e.DOWN=3]="DOWN"}(he||(he={}));const me={[he.LEFT]:new Z(-1,0),[he.RIGHT]:new Z(1,0),[he.UP]:new Z(0,-1),[he.DOWN]:new Z(0,1)};class be{constructor(e,t,i){this.bounds=e,this.start=t,this.steps=i,this.children=[]}step(e){return me[this.steps[e]]}isInside(e){if(!this.bounds.overlap(e.bounds))return!1;if(0==this.steps.length)return e.bounds.containsRect(this.bounds);let t,i=this.start;for(let n=0;n<this.steps.length&&(t=e.windingNumber(i))==ce;n++)i=i.move(this.step(n));if(t==ce){i=e.start;for(let n=0;n<e.steps.length&&(t=this.windingNumber(i))==ce;n++)i=i.move(this.step(n));return t==ce||0==t}return 0!=t}windingNumber(e){let t=this.start.subtract(e),i=0;for(let e=0;e<this.steps.length;e++){const n=this.step(e),r=t.add(n);if(t.dy<=0&&r.dy>0){const e=t.crossProduct(n);if(e<0)i++;else if(0==e)return ce}else if(t.dy>0&&r.dy<=0){const e=t.crossProduct(n);if(e>0)i--;else if(0==e)return ce}t=r}return i}isLegallyNested(){if(0==this.steps.length)return!0;const e=this.outerArea();for(let t of this.children)if(t.outerArea()*e>0||!t.isLegallyNested())return!1;return!0}outerArea(){if(0==this.steps.length)return this.bounds.area();let e=this.start,t=0;for(let i=0;i<this.steps.length;i++){const n=this.step(i);n.dx>0?t+=e.y:n.dx<0&&(t-=e.y),e=e.move(n)}return t}area(){let e=this.outerArea();return this.children.forEach(t=>{e+=t.area()}),e}}class fe{constructor(e,t){this.pos=e,this.stepDir=t,this.prev=this,this.next=this}nextPoint(){return this.pos.move(me[this.stepDir])}joinWith(e){const t=this.nextPoint();t.x==e.pos.x&&t.y==e.pos.y?(this.prev=e.prev,this.prev.next=this,this.next=e,e.prev=this):(this.next=e.next,this.next.prev=this,this.prev=e,e.next=this)}buildOutline(){const e=[];let t=this,i=this.pos,n=i.rect(0,0);do{e.push(t.stepDir),i=i.move(me[t.stepDir]),n=n.unionPoint(i),t=t.next}while(t!=this);return new be(n,this.pos,e)}}class ge{constructor(e,t){this.image=e,this.block=t,this.scanX=0,this.scanY=0,this.outlines=[],this.current=null,this.pendingEdges=new Array(t.width+1),this.scanX=t.x,this.scanY=t.y}process(){for(;!this.step(););return this.outlines}getPixel(e,t){return this.block.containsPoint(Q(e,t))?this.image.getPixel(e,t):255}step(){const e=this.getPixel(this.scanX,this.scanY),t=this.getPixel(this.scanX-1,this.scanY),i=this.getPixel(this.scanX,this.scanY-1),n=this.scanX-this.block.x;if(this.pendingEdges[n])if(e==t)e==i?(this.joinEdges(this.current,this.pendingEdges[n]),this.current=null):this.current=this.horizontalEdge(i-e,this.pendingEdges[n]),this.pendingEdges[n]=null;else if(e==i)this.pendingEdges[n]=this.verticalEdge(e-t,this.pendingEdges[n]);else if(e==pe.WHITE)this.joinEdges(this.current,this.pendingEdges[n]),this.current=this.horizontalEdge(i-e,null),this.pendingEdges[n]=this.verticalEdge(e-t,this.current);else{const r=this.horizontalEdge(i-e,this.pendingEdges[n]);this.pendingEdges[n]=this.verticalEdge(e-t,this.current),this.current=r}else e!=t&&(this.pendingEdges[n]=this.current=this.verticalEdge(e-t,this.current)),this.current=e!=i?this.horizontalEdge(i-e,this.current):null;return this.scanX+=1,this.scanX>this.block.corner().x&&(this.scanY+=1,this.scanX=this.block.x-1),this.scanY>this.block.corner().y}horizontalEdge(e,t){const i=e>0?new fe(Q(this.scanX+1,this.scanY),he.LEFT):new fe(Q(this.scanX,this.scanY),he.RIGHT);return null!=t&&i.joinWith(t),i}verticalEdge(e,t){const i=e<0?new fe(Q(this.scanX,this.scanY),he.DOWN):new fe(Q(this.scanX,this.scanY+1),he.UP);return null!=t&&i.joinWith(t),i}joinEdges(e,t){const i=e.nextPoint();if(i.x!=t.pos.x||i.y!=t.pos.y){const i=e;e=t,t=i}if(e.next==t){const t=e.buildOutline();t.steps.length>=8&&this.outlines.push(t)}else t.prev.next=e.next,e.next.prev=t.prev,e.next=t,t.prev=e}}const ye=[];function xe(e,t=n){let i;const r=[];function o(t){if(l(e,t)&&(e=t,i)){const t=!ye.length;for(let t=0;t<r.length;t+=1){const i=r[t];i[1](),ye.push(i,e)}if(t){for(let e=0;e<ye.length;e+=2)ye[e][0](ye[e+1]);ye.length=0}}}return{set:o,update:function(t){o(t(e))},subscribe:function(a,s=n){const l=[a,s];return r.push(l),1===r.length&&(i=t(o)||n),a(e),()=>{const e=r.indexOf(l);-1!==e&&r.splice(e,1),0===r.length&&(i(),i=null)}}}}const ve=xe({nodes:[]}),ke=xe([]),we=xe(null);var Ce;!function(e){e.COLOR="color",e.IMAGE="image",e.ARRAY="array",e.CATALOG_IMAGE="catalog-image"}(Ce||(Ce={}));q.CommonValueType.STRING;const Te={type:Ce.IMAGE},Se={type:Ce.ARRAY},Re={type:Ce.CATALOG_IMAGE},Ee={nodeDefinition:{id:"image-input",label:"Image Input",preview:!0,categories:"io",properties:[{id:"image",label:"Image",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Te},{id:"name",label:"Name",type:q.PropertyType.INPUT,editable:!0,linkable:!1,valueType:Re}]},evaluate:e=>{const t={};let i=void 0;if(e.name){const n=He.find(t=>t.name==e.name);n&&(t.image=n.data,i=t.image)}return{outputs:t,preview:i}}},Pe={nodeDefinition:{id:"viewer",label:"Viewer",preview:!0,categories:"io",properties:[{id:"image",label:"Image",type:q.PropertyType.INPUT,linkable:!0,valueType:Te},{id:"marks",label:"Marks",type:q.PropertyType.INPUT,linkable:!0,valueType:Se}]},evaluate:e=>{let t=void 0;if(e.image){const n=e.image;Be.width=n.width,Be.height=n.height,Ae.clearRect(0,0,n.width,n.height),Ae.putImageData(n,0,0);let r=[],o=[];if(e.marks){let t=e.marks;function i(e,t){o.push(...t),r.push({name:e,marks:t})}if(t.outlines)i("outlines",t.outlines.map(e=>e.bounds));else{const e=t;i("blobs",e.blobs.map(e=>e.boundingBox())),i("noises",e.noises.map(e=>e.boundingBox())),i("smalls",e.smalls.map(e=>e.boundingBox())),i("larges",e.larges.map(e=>e.boundingBox()))}Ae.strokeStyle="#0000FF";for(let e=0;e<o.length;++e){const t=o[e];Ae.beginPath(),Ae.rect(t.x,t.y,t.width,t.height),Ae.closePath(),Ae.stroke()}}t=Ae.getImageData(0,0,n.width,n.height),we.set({image:n,layers:r})}return{outputs:{},preview:t}}},Be=document.createElement("canvas"),Ae=Be.getContext("2d"),Me={nodeDefinition:{id:"chart-viewer",label:"Chart Viewer",preview:!0,categories:"io",properties:[{id:"values",label:"Values",type:q.PropertyType.INPUT,linkable:!0,valueType:Se}]},evaluate:e=>{let t=void 0;if(e.values){const i=e.values;Be.width=500,Be.height=500,Ae.clearRect(0,0,500,500);const n=500/i.length;let r=0;for(let e=0;e<i.length;++e)r=Math.max(r,i[e]);Ae.fillStyle="#4a83fd",Ae.beginPath(),Ae.moveTo(0,500);for(let e=0;e<i.length;++e){const t=500*i[e]/r;Ae.lineTo(e*n,500-t)}Ae.closePath(),Ae.fill(),t=Ae.getImageData(0,0,500,500)}return{outputs:{},preview:t}}},Oe={nodeDefinition:{id:"grayscale",label:"Grayscale",categories:"color",properties:[{id:"output",label:"Output",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Te},{id:"input",label:"Input",type:q.PropertyType.INPUT,linkable:!0,valueType:Te}]},evaluate:e=>{const t={};return e.input&&(t.output=function(e){const t=ie.createImageData(e);function i(e,i){t.data[e]=255&i,t.data[e+1]=255&i,t.data[e+2]=255&i,t.data[e+3]=255}for(let t=0;t<e.data.length;t+=4){i(t,.2126*e.data[t]+.7152*e.data[t+1]+.0722*e.data[t+2])}return t}(e.input)),{outputs:t,preview:void 0}}},Le={nodeDefinition:{id:"histogram",label:"Histogram",categories:"analysis",properties:[{id:"histogram",label:"Histogram",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Se},{id:"image",label:"Image",type:q.PropertyType.INPUT,linkable:!0,valueType:Te}]},evaluate:e=>{const t={};return e.image&&(t.histogram=function(e){const t=new Array(256).fill(0);for(let i=0;i<e.data.length;i+=4){t[e.data[i]]++}return t}(e.image)),{outputs:t,preview:void 0}}},Ge={nodeDefinition:{id:"marching-squares",label:"Marching Squares",categories:"segmentation",properties:[{id:"outlines",label:"Outlines",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Se},{id:"image",label:"Image",type:q.PropertyType.INPUT,linkable:!0,valueType:Te}]},evaluate:e=>{const t={};if(e.image){const i=e.image,n={width:i.width,height:i.height,mode:de.BINARY,getPixel:(e,t)=>i.data[4*(t*i.width+e)]},r=Q(0,0).rect(i.width,i.height),o=new ge(n,r).process();t.outlines={bounds:r,outlines:o}}return{outputs:t,preview:void 0}}},ze={nodeDefinition:{id:"blob-hierarchy",label:"Blob Hierarchy",categories:"segmentation",properties:[{id:"blobs",label:"Blobs",type:q.PropertyType.OUTPUT,linkable:!0,valueType:{type:"any"}},{id:"outlines",label:"Outlines",type:q.PropertyType.INPUT,linkable:!0,valueType:{type:"any"}},{id:"filter-blobs",label:"Filter Blobs",type:q.PropertyType.INPUT,linkable:!1,editable:!0,valueType:{type:q.CommonValueType.BOOLEAN},defaultValue:!1}]},evaluate:e=>{const t={};if(e.outlines){const i=e.outlines,n=new ue(i.bounds);!function(e,t){const i=new re(e.bounds);i.fillWith(t,e=>e.bounds.origin()),i.forEach(t=>{for(;t.length>0;){const n=[];let r=0;for(let e=r+1;e<t.length;++e)t[r].isInside(t[e])&&(r=e);const o=t.splice(r,1)[0];n.push(o);se(ae(i,o,n),n,e)}})}(n,i.outlines),e["filter-blobs"]&&n.filterBlobs(),t.blobs=n}return{outputs:t,preview:void 0}}},Ne=[Ee,Pe,Me,Oe,Le,{nodeDefinition:{id:"otsu-levels",label:"Otsu Levels",categories:"binarize",properties:[{id:"levels",label:"Levels",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Se},{id:"histogram",label:"Histogram",type:q.PropertyType.INPUT,linkable:!0,valueType:Se}]},evaluate:e=>{const t={};return e.histogram&&(t.levels=function(e){let t=0;for(let i=0;i<e.length;++i)t+=e[i];let i=0;for(let n=0;n<e.length;++n)i+=n*e[n]/t;let n=0,r=0;const o=[];for(let a=0;a<e.length;++a){const s=1-r;if(r>0&&s>0){const e=(i-n)/s,t=n/r,a=r*s*Math.pow(t-e,2);o.push(a)}else o.push(0);r+=e[a]/t,n+=a*e[a]/t}return o}(e.histogram)),{outputs:t,preview:void 0}}},{nodeDefinition:{id:"binarization",label:"Binarization",categories:"binarize",properties:[{id:"output",label:"Output",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Te},{id:"input",label:"Input",type:q.PropertyType.INPUT,linkable:!0,valueType:Te},{id:"level",label:"Level",type:q.PropertyType.INPUT,linkable:!0,editable:!0,defaultValue:128,valueType:{type:q.CommonValueType.INTEGER,range:{min:0,max:255}}}]},evaluate:e=>{const t={};return e.input&&null!=e.level&&(t.output=function(e,t){const i=ie.createImageData(e);function n(e,t){i.data[e]=255&t,i.data[e+1]=255&t,i.data[e+2]=255&t,i.data[e+3]=255}for(let i=0;i<e.data.length;i+=4)n(i,e.data[i]>t?255:0);return i}(e.input,e.level)),{outputs:t,preview:void 0}}},{nodeDefinition:{id:"distance",label:"Distance",categories:"analysis",properties:[{id:"output",label:"Output",type:q.PropertyType.OUTPUT,linkable:!0,valueType:Te},{id:"input",label:"Input",type:q.PropertyType.INPUT,linkable:!0,valueType:Te}]},evaluate:e=>{const t={};if(e.input){const{max:i,result:n,image:r}=function(e){const t=new Uint8Array(e.width*e.height);function i(i,n,r){t[i*e.width+n]=r}function n(i,n){return t[i*e.width+n]}for(let t=0;t<e.height;t++)for(let n=0;n<e.width;n++)i(t,n,0==e.data[4*(t*e.width+n)]?1:0);let r=0;for(let t=1;t<e.height;t++)for(let o=1;o<e.width;o++){if(n(t,o)>0){const e=n(t-1,o),a=n(t,o-1),s=Math.min(Math.min(e,a)+1,255);r=Math.max(r,s),i(t,o,s)}}for(let t=e.height-1;t>0;t--)for(let o=e.width-1;o>0;o--){const e=n(t,o);if(e>0){const a=n(t+1,o),s=n(t,o+1),l=Math.min(Math.min(s,a)+1,e);r=Math.max(r,l),i(t,o,l)}}const o=ie.createImageData(e.width,e.height);function a(e,t){o.data[e+0]=255&t,o.data[e+1]=255&t,o.data[e+2]=255&t,o.data[e+3]=255}for(let e=0;e<o.height;e++)for(let t=0;t<o.width;t++){const i=Math.floor(255*n(e,t)/r);a(4*(e*o.width+t),i)}return{max:r,result:t,image:o}}(e.input);console.log(r),t.output=r}return{outputs:t,preview:void 0}}},Ge,ze,{nodeDefinition:{id:"argmax",label:"Argmax",categories:"math",properties:[{id:"value",label:"Value",type:q.PropertyType.OUTPUT,linkable:!0,valueType:{type:q.CommonValueType.INTEGER}},{id:"values",label:"Values",type:q.PropertyType.INPUT,linkable:!0,valueType:Se}]},evaluate:e=>{const t={};return e.values&&(t.value=function(e){let t=0,i=-1;for(let n=0;n<e.length;++n){const r=e[n];r>=t&&(i=n,t=r)}return i}(e.values)),{outputs:t,preview:void 0}}}],Ie=Ne.map(e=>e.nodeDefinition);let He=[];ke.subscribe(e=>{He=e});const Ve={handlerMouseDown(e,t,i){if(i.globalBounds().shrink(2*e.renderer.style.unit,0).contains(t.position)){const t=i.globalBounds().bottomLeft(),n=e.openSelector(t,"select-tree",{nodes:He.map(e=>({name:e.name,title:e.name}))});return n.result.then(t=>{e.emit(new q.ChangePropertyValueCommand(i.property,t.name))},()=>{}),n.state}return new q.IdleState},layout(e,t){const i=e.context.measureText(t.property.definition.label);t.bounds=new q.Point(0,0).rect(i.width+3*e.style.unit,4*e.style.unit)},draw(e,t){const i=t.globalBounds(),n=e.style,r=i.shrink(2*n.unit,0).withHeight(4*n.unit);e.roundBox().filled(Object(q.rgb)(e.theme.PROPERTY_COLOR)).draw(r),e.drawText(i.origin.offset(5*n.unit,3*n.unit),Object(q.rgb)(e.theme.TEXT_COLOR),t.property.definition.label+":");const o=t.getValue(),a=o?o.toString():"";e.drawText(i.topRight().offset(5*-n.unit,3*n.unit),Object(q.rgb)(e.theme.TEXT_COLOR),a,q.Align.RIGHT)}};const De=new class{getHeaderColor(e){return"io"==e.definition.categories?{r:236,g:115,b:55}:{r:0,g:169,b:106}}getConnectorColor(e){return e.definition.valueType.type==Ce.IMAGE?{r:199,g:199,b:41}:e.definition.valueType.type==Ce.ARRAY?{r:64,g:99,b:199}:{r:161,g:161,b:161}}getPropertyHandler(e){return e.definition.valueType.type==Ce.CATALOG_IMAGE?Ve:Object(q.getDefaultPropertyHandler)(e)}},Fe=new q.NodeFactory(Ie);function Ue(e){let t,i,n,r;function o(e,t){return"string"==typeof e[8][4]?$e:_e}let a=o(e),s=a(e);return{c(){t=b("svg"),i=b("g"),n=b("g"),s.c(),x(n,"transform",e[10]),x(i,"transform","translate(256 256)"),x(t,"id",e[1]),x(t,"class",e[0]),x(t,"style",e[9]),x(t,"viewBox",r=`0 0 ${e[8][0]} ${e[8][1]}`),x(t,"aria-hidden","true"),x(t,"role","img"),x(t,"xmlns","http://www.w3.org/2000/svg")},m(e,r){p(e,t,r),d(t,i),d(i,n),s.m(n,null)},p(e,i){a===(a=o(e))&&s?s.p(e,i):(s.d(1),s=a(e),s&&(s.c(),s.m(n,null))),1024&i&&x(n,"transform",e[10]),2&i&&x(t,"id",e[1]),1&i&&x(t,"class",e[0]),512&i&&x(t,"style",e[9]),256&i&&r!==(r=`0 0 ${e[8][0]} ${e[8][1]}`)&&x(t,"viewBox",r)},d(e){e&&c(t),s.d()}}}function _e(e){let t,i,n,r,o,a,s,l;return{c(){t=b("path"),o=b("path"),x(t,"d",i=e[8][4][0]),x(t,"fill",n=e[4]||e[2]||"currentColor"),x(t,"fill-opacity",r=0!=e[7]?e[5]:e[6]),x(t,"transform","translate(-256 -256)"),x(o,"d",a=e[8][4][1]),x(o,"fill",s=e[3]||e[2]||"currentColor"),x(o,"fill-opacity",l=0!=e[7]?e[6]:e[5]),x(o,"transform","translate(-256 -256)")},m(e,i){p(e,t,i),p(e,o,i)},p(e,u){256&u&&i!==(i=e[8][4][0])&&x(t,"d",i),20&u&&n!==(n=e[4]||e[2]||"currentColor")&&x(t,"fill",n),224&u&&r!==(r=0!=e[7]?e[5]:e[6])&&x(t,"fill-opacity",r),256&u&&a!==(a=e[8][4][1])&&x(o,"d",a),12&u&&s!==(s=e[3]||e[2]||"currentColor")&&x(o,"fill",s),224&u&&l!==(l=0!=e[7]?e[6]:e[5])&&x(o,"fill-opacity",l)},d(e){e&&c(t),e&&c(o)}}}function $e(e){let t,i,n;return{c(){t=b("path"),x(t,"d",i=e[8][4]),x(t,"fill",n=e[2]||e[3]||"currentColor"),x(t,"transform","translate(-256 -256)")},m(e,i){p(e,t,i)},p(e,r){256&r&&i!==(i=e[8][4])&&x(t,"d",i),12&r&&n!==(n=e[2]||e[3]||"currentColor")&&x(t,"fill",n)},d(e){e&&c(t)}}}function We(e){let t,i=e[8][4]&&Ue(e);return{c(){i&&i.c(),t=f("")},m(e,n){i&&i.m(e,n),p(e,t,n)},p(e,[n]){e[8][4]?i?i.p(e,n):(i=Ue(e),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i:n,o:n,d(e){i&&i.d(e),e&&c(t)}}}function Xe(e,t,i){let n,r,o,{class:a=""}=t,{id:s=""}=t,{style:l=""}=t,{icon:u}=t,{fw:d=!1}=t,{flip:p=!1}=t,{pull:c=""}=t,{rotate:h=""}=t,{size:m=""}=t,{color:b=""}=t,{primaryColor:f=""}=t,{secondaryColor:g=""}=t,{primaryOpacity:y=1}=t,{secondaryOpacity:x=.4}=t,{swapOpacity:v=!1}=t;return e.$$set=e=>{"class"in e&&i(0,a=e.class),"id"in e&&i(1,s=e.id),"style"in e&&i(11,l=e.style),"icon"in e&&i(12,u=e.icon),"fw"in e&&i(13,d=e.fw),"flip"in e&&i(14,p=e.flip),"pull"in e&&i(15,c=e.pull),"rotate"in e&&i(16,h=e.rotate),"size"in e&&i(17,m=e.size),"color"in e&&i(2,b=e.color),"primaryColor"in e&&i(3,f=e.primaryColor),"secondaryColor"in e&&i(4,g=e.secondaryColor),"primaryOpacity"in e&&i(5,y=e.primaryOpacity),"secondaryOpacity"in e&&i(6,x=e.secondaryOpacity),"swapOpacity"in e&&i(7,v=e.swapOpacity)},e.$$.update=()=>{if(4096&e.$$.dirty&&i(8,n=u&&u.icon||[0,0,"",[],""]),174080&e.$$.dirty){let e,t;const n="1em";let o,a,s,u="-.125em";const p="visible";d&&(s="center",t="1.25em"),c&&(e=c),m&&("lg"==m?(a="1.33333em",o=".75em",u="-.225em"):a="xs"==m?".75em":"sm"==m?".875em":m.replace("x","em"));const h={float:e,width:t,height:n,"line-height":o,"font-size":a,"text-align":s,"vertical-align":u,overflow:p};let b="";for(const e in h)h[e]&&(b+=`${e}:${h[e]};`);i(9,r=b+l)}if(81920&e.$$.dirty){let e="";if(p){let t=1,i=1;"horizontal"==p?t=-1:"vertical"==p?i=-1:t=i=-1,e+=` scale(${t} ${i})`}h&&(e+=` rotate(${h} 0 0)`),i(10,o=e)}},[a,s,b,f,g,y,x,v,n,r,o,l,u,d,p,c,h,m]}var Ye=class extends K{constructor(e){super(),j(this,e,Xe,We,l,{class:0,id:1,style:11,icon:12,fw:13,flip:14,pull:15,rotate:16,size:17,color:2,primaryColor:3,secondaryColor:4,primaryOpacity:5,secondaryOpacity:6,swapOpacity:7})}},je={prefix:"fas",iconName:"arrow-down",icon:[448,512,[],"f063","M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z"]},Ke={prefix:"fas",iconName:"arrow-up",icon:[448,512,[],"f062","M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"]},qe={prefix:"fas",iconName:"book",icon:[448,512,[],"f02d","M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z"]},Ze={prefix:"fas",iconName:"compress",icon:[448,512,[],"f066","M436 192H312c-13.3 0-24-10.7-24-24V44c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v84h84c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm-276-24V44c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v84H12c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24zm0 300V344c0-13.3-10.7-24-24-24H12c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-84h84c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12H312c-13.3 0-24 10.7-24 24v124c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12z"]},Je={prefix:"fas",iconName:"crosshairs",icon:[512,512,[],"f05b","M500 224h-30.364C455.724 130.325 381.675 56.276 288 42.364V12c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v30.364C130.325 56.276 56.276 130.325 42.364 224H12c-6.627 0-12 5.373-12 12v40c0 6.627 5.373 12 12 12h30.364C56.276 381.675 130.325 455.724 224 469.636V500c0 6.627 5.373 12 12 12h40c6.627 0 12-5.373 12-12v-30.364C381.675 455.724 455.724 381.675 469.636 288H500c6.627 0 12-5.373 12-12v-40c0-6.627-5.373-12-12-12zM288 404.634V364c0-6.627-5.373-12-12-12h-40c-6.627 0-12 5.373-12 12v40.634C165.826 392.232 119.783 346.243 107.366 288H148c6.627 0 12-5.373 12-12v-40c0-6.627-5.373-12-12-12h-40.634C119.768 165.826 165.757 119.783 224 107.366V148c0 6.627 5.373 12 12 12h40c6.627 0 12-5.373 12-12v-40.634C346.174 119.768 392.217 165.757 404.634 224H364c-6.627 0-12 5.373-12 12v40c0 6.627 5.373 12 12 12h40.634C392.232 346.174 346.243 392.217 288 404.634zM288 256c0 17.673-14.327 32-32 32s-32-14.327-32-32c0-17.673 14.327-32 32-32s32 14.327 32 32z"]},Qe={prefix:"fas",iconName:"expand",icon:[448,512,[],"f065","M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z"]},et={prefix:"fas",iconName:"eye",icon:[576,512,[],"f06e","M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"]},tt={prefix:"fas",iconName:"file-export",icon:[576,512,[],"f56e","M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z"]},it={prefix:"fas",iconName:"image",icon:[512,512,[],"f03e","M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"]},nt={prefix:"fas",iconName:"layer-group",icon:[512,512,[],"f5fd","M12.41 148.02l232.94 105.67c6.8 3.09 14.49 3.09 21.29 0l232.94-105.67c16.55-7.51 16.55-32.52 0-40.03L266.65 2.31a25.607 25.607 0 0 0-21.29 0L12.41 107.98c-16.55 7.51-16.55 32.53 0 40.04zm487.18 88.28l-58.09-26.33-161.64 73.27c-7.56 3.43-15.59 5.17-23.86 5.17s-16.29-1.74-23.86-5.17L70.51 209.97l-58.1 26.33c-16.55 7.5-16.55 32.5 0 40l232.94 105.59c6.8 3.08 14.49 3.08 21.29 0L499.59 276.3c16.55-7.5 16.55-32.5 0-40zm0 127.8l-57.87-26.23-161.86 73.37c-7.56 3.43-15.59 5.17-23.86 5.17s-16.29-1.74-23.86-5.17L70.29 337.87 12.41 364.1c-16.55 7.5-16.55 32.5 0 40l232.94 105.59c6.8 3.08 14.49 3.08 21.29 0L499.59 404.1c16.55-7.5 16.55-32.5 0-40z"]},rt={prefix:"fas",iconName:"minus",icon:[448,512,[],"f068","M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]},ot={prefix:"fas",iconName:"plus",icon:[448,512,[],"f067","M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]},at={prefix:"fas",iconName:"trash",icon:[448,512,[],"f1f8","M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z"]};
/*!
 * Font Awesome Free 5.15.3 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */i(8);function st(e){let t,i,n,r,o;return i=new Ye({props:{icon:e[0]}}),{c(){t=m("button"),W(i.$$.fragment),x(t,"class","round svelte-njfq9m")},m(a,s){p(a,t,s),X(i,t,null),n=!0,r||(o=y(t,"click",e[1]),r=!0)},p(e,[t]){const n={};1&t&&(n.icon=e[0]),i.$set(n)},i(e){n||(U(i.$$.fragment,e),n=!0)},o(e){_(i.$$.fragment,e),n=!1},d(e){e&&c(t),Y(i),r=!1,o()}}}function lt(e,t,i){let{icon:n}=t;return e.$$set=e=>{"icon"in e&&i(0,n=e.icon)},[n,function(t){!function(e,t){const i=e.$$.callbacks[t.type];i&&i.slice().forEach(e=>e(t))}(e,t)}]}var ut=class extends K{constructor(e){super(),j(this,e,lt,st,l,{icon:0})}};i(10);function dt(e){let t,i,r;return{c(){t=m("pre"),i=m("code"),r=f(e[0]),x(t,"class","svelte-1qi2sn1")},m(e,n){p(e,t,n),d(t,i),d(i,r)},p(e,[t]){1&t&&v(r,e[0])},i:n,o:n,d(e){e&&c(t)}}}function pt(e,t,i){let n="";return S(()=>ve.subscribe(e=>{i(0,n=JSON.stringify(Fe.save(e),null,2))})),[n]}var ct=class extends K{constructor(e){super(),j(this,e,pt,dt,l,{})}};const ht=new class{constructor(){this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d")}changeImage(e,t){this.canvas.width=e.width,this.canvas.height=e.height,this.ctx.drawImage(e,0,0);const i=this.ctx.getImageData(0,0,e.width,e.height);this.resolve({name:t,data:i})}load(e){return this.loadImage(e,e.name)}loadURL(e,t){return fetch(t).then(e=>e.blob()).then(t=>this.loadImage(t,e))}loadImage(e,t){const i=new FileReader,n=new Image;return n.onload=()=>this.changeImage(n,t),n.onerror=()=>this.reject(),i.onload=e=>{n.src=e.target.result},i.onerror=()=>this.reject(),i.readAsDataURL(e),new Promise((e,t)=>{this.resolve=e,this.reject=t})}};i(12);function mt(e,t,i){const n=e.slice();return n[5]=t[i],n}function bt(e){let t,i,n,r,o,a=e[5].name+"";return r=new ut({props:{icon:at}}),r.$on("click",(function(...t){return e[4](e[5],...t)})),{c(){t=m("li"),i=f(a),n=g(),W(r.$$.fragment)},m(e,a){p(e,t,a),d(t,i),d(t,n),X(r,t,null),o=!0},p(t,n){e=t,(!o||1&n)&&a!==(a=e[5].name+"")&&v(i,a)},i(e){o||(U(r.$$.fragment,e),o=!0)},o(e){_(r.$$.fragment,e),o=!1},d(e){e&&c(t),Y(r)}}}function ft(e){let t,i,n,r,o,a,s=e[0],l=[];for(let t=0;t<s.length;t+=1)l[t]=bt(mt(e,s,t));const u=e=>_(l[e],1,1,()=>{l[e]=null});return{c(){t=m("input"),i=g(),n=m("ul");for(let e=0;e<l.length;e+=1)l[e].c();x(t,"type","file"),x(t,"accept","image/png, image/jpeg"),x(t,"class","svelte-1lk0m5a"),x(n,"class","svelte-1lk0m5a")},m(s,u){p(s,t,u),p(s,i,u),p(s,n,u);for(let e=0;e<l.length;e+=1)l[e].m(n,null);r=!0,o||(a=y(t,"change",e[3]),o=!0)},p(e,[t]){if(5&t){let i;for(s=e[0],i=0;i<s.length;i+=1){const r=mt(e,s,i);l[i]?(l[i].p(r,t),U(l[i],1)):(l[i]=bt(r),l[i].c(),U(l[i],1),l[i].m(n,null))}for(D(),i=s.length;i<l.length;i+=1)u(i);F()}},i(e){if(!r){for(let e=0;e<s.length;e+=1)U(l[e]);r=!0}},o(e){l=l.filter(Boolean);for(let e=0;e<l.length;e+=1)_(l[e]);r=!1},d(e){e&&c(t),e&&c(i),e&&c(n),h(l,e),o=!1,a()}}}function gt(e,t,i){let n=[];function r(e){ht.load(e[0]).then(e=>{ke.set(n.concat(e))},()=>{})}function o(e){ke.set(n.filter(t=>t!=e))}S(()=>ke.subscribe(e=>{i(0,n=e)}));return[n,r,o,e=>r(e.srcElement.files),e=>o(e)]}var yt=class extends K{constructor(e){super(),j(this,e,gt,ft,l,{})}};i(14);function xt(e,t,i){const n=e.slice();return n[33]=t[i],n[34]=t,n[35]=i,n}function vt(e){let t,i=e[0].layers,n=[];for(let t=0;t<i.length;t+=1)n[t]=kt(xt(e,i,t));return{c(){t=m("ul");for(let e=0;e<n.length;e+=1)n[e].c();x(t,"class","svelte-qiruuj")},m(e,i){p(e,t,i);for(let e=0;e<n.length;e+=1)n[e].m(t,null)},p(e,r){if(193&r[0]){let o;for(i=e[0].layers,o=0;o<i.length;o+=1){const a=xt(e,i,o);n[o]?n[o].p(a,r):(n[o]=kt(a),n[o].c(),n[o].m(t,null))}for(;o<n.length;o+=1)n[o].d(1);n.length=i.length}},d(e){e&&c(t),h(n,e)}}}function kt(e){let t,i,n,r,o,s,l,u,h,b=e[33].name+"",k=e[33].marks.length+"";function w(){e[20].call(i,e[33])}return{c(){t=m("li"),i=m("input"),n=g(),r=f(b),o=f(" ("),s=f(k),l=f(")"),x(i,"type","checkbox")},m(a,c){p(a,t,c),d(t,i),i.checked=e[6][e[33].name],d(t,n),d(t,r),d(t,o),d(t,s),d(t,l),u||(h=[y(i,"change",w),y(i,"change",e[21])],u=!0)},p(t,n){e=t,65&n[0]&&(i.checked=e[6][e[33].name]),1&n[0]&&b!==(b=e[33].name+"")&&v(r,b),1&n[0]&&k!==(k=e[33].marks.length+"")&&v(s,k)},d(e){e&&c(t),u=!1,a(h)}}}function wt(e){let t,i,n,r,o,s,l,u,h,b,f,v,w,C,T,S;n=new ut({props:{icon:Je}}),n.$on("click",e[16]),o=new ut({props:{icon:ot}}),o.$on("click",e[17]),l=new ut({props:{icon:rt}}),l.$on("click",e[18]),h=new ut({props:{icon:nt}}),h.$on("click",e[19]);let R=e[0]&&e[0].layers&&vt(e);return{c(){t=m("div"),i=m("div"),W(n.$$.fragment),r=g(),W(o.$$.fragment),s=g(),W(l.$$.fragment),u=g(),W(h.$$.fragment),b=g(),f=m("div"),R&&R.c(),v=g(),w=m("canvas"),x(f,"class","layer-selector svelte-qiruuj"),k(f,"hide",e[5]),x(i,"class","toolbar svelte-qiruuj"),k(i,"hide",0==e[4]),x(w,"width",e[3]),x(w,"height",e[4]),x(t,"class","main svelte-qiruuj")},m(a,c){p(a,t,c),d(t,i),X(n,i,null),d(i,r),X(o,i,null),d(i,s),X(l,i,null),d(i,u),X(h,i,null),d(i,b),d(i,f),R&&R.m(f,null),d(t,v),d(t,w),e[22](w),e[23](t),C=!0,T||(S=[y(w,"mousedown",e[12]),y(w,"mouseup",e[13]),y(w,"mousemove",e[14])],T=!0)},p(e,t){e[0]&&e[0].layers?R?R.p(e,t):(R=vt(e),R.c(),R.m(f,null)):R&&(R.d(1),R=null),32&t[0]&&k(f,"hide",e[5]),16&t[0]&&k(i,"hide",0==e[4]),(!C||8&t[0])&&x(w,"width",e[3]),(!C||16&t[0])&&x(w,"height",e[4])},i(e){C||(U(n.$$.fragment,e),U(o.$$.fragment,e),U(l.$$.fragment,e),U(h.$$.fragment,e),C=!0)},o(e){_(n.$$.fragment,e),_(o.$$.fragment,e),_(l.$$.fragment,e),_(h.$$.fragment,e),C=!1},d(i){i&&c(t),Y(n),Y(o),Y(l),Y(h),R&&R.d(),e[22](null),e[23](null),T=!1,a(S)}}}function Ct(e,t,i){let n,r,o,a,s,l,u,d,p,c,h={x:0,y:0},m=1,b=!0,f=!1,g=!0,y={};function x(){if(n){if(a.clearRect(0,0,s,l),a.save(),a.translate(h.x,h.y),a.scale(m,m),a.drawImage(u,0,0),n.layers){const e=["blue","red","green","orange","purple"];a.strokeWidth="2px",n.layers.forEach((t,i)=>{y[t.name]&&(a.strokeStyle=e[i%e.length],t.marks.forEach(e=>{a.beginPath(),a.rect(e.x,e.y,e.width,e.height),a.stroke()}))})}a.restore()}}function v(){n&&s&&l&&(b=!1,m=Math.min(s/n.image.width,l/n.image.height),h={x:0,y:0},x())}function k(){m*=1.2,x()}function w(){m/=1.2,x()}function C(){i(5,g=!g)}S(()=>(a=o.getContext("2d"),u=document.createElement("canvas"),d=u.getContext("2d"),we.subscribe(e=>{i(0,n=e),n&&(u.width=n.image.width,u.height=n.image.height,d.putImageData(n.image,0,0),n.layers&&(i(6,y={}),n.layers.forEach(e=>i(6,y[e.name]=!0,y))),v())})));return[n,r,o,s,l,g,y,x,v,k,w,C,function(e){f=!0,p={x:e.clientX,y:e.clientY},c=h},function(e){f=!1},function(e){if(f){const t=e.clientX-p.x,i=e.clientY-p.y;h={x:Math.min(c.x+t,0),y:Math.min(c.y+i,0)},x()}},function(){const e=r.getBoundingClientRect();i(3,s=e.width),i(4,l=e.height),setTimeout(()=>{b?v():x()},10)},()=>v(),()=>k(),()=>w(),()=>C(),function(e){y[e.name]=this.checked,i(6,y),i(0,n)},e=>x(),function(e){E[e?"unshift":"push"](()=>{o=e,i(2,o)})},function(e){E[e?"unshift":"push"](()=>{r=e,i(1,r)})}]}var Tt=class extends K{constructor(e){super(),j(this,e,Ct,wt,l,{refresh:15},[-1,-1])}get refresh(){return this.$$.ctx[15]}};i(16);function St(e){let t;return{c(){t=m("p"),t.textContent="Library",x(t,"class","svelte-cgc3zo")},m(e,i){p(e,t,i)},p:n,i:n,o:n,d(e){e&&c(t)}}}var Rt=class extends K{constructor(e){super(),j(this,e,null,St,l,{})}};i(18);function Et(e,t,i){const n=e.slice();return n[11]=t[i],n}function Pt(e){let t,i,n,r,o,a,s,l=e[11].label+"";function u(...t){return e[7](e[11],...t)}return n=new Ye({props:{class:"icon",icon:e[11].icon}}),{c(){t=m("li"),i=m("span"),W(n.$$.fragment),r=f(l),x(i,"class","svelte-bkw2mk"),x(t,"class","svelte-bkw2mk"),k(t,"active",e[11]==e[1])},m(e,l){p(e,t,l),d(t,i),X(n,i,null),d(i,r),o=!0,a||(s=y(i,"click",u),a=!0)},p(i,n){e=i,10&n&&k(t,"active",e[11]==e[1])},i(e){o||(U(n.$$.fragment,e),o=!0)},o(e){_(n.$$.fragment,e),o=!1},d(e){e&&c(t),Y(n),a=!1,s()}}}function Bt(e){let t,i,n,r,o,a,s,l,u,b,f,y,v=e[3],w=[];for(let t=0;t<v.length;t+=1)w[t]=Pt(Et(e,v,t));const C=e=>_(w[e],1,1,()=>{w[e]=null});a=new ut({props:{icon:e[0]!=At?Qe:Ze}}),a.$on("click",e[8]),l=new ut({props:{icon:e[0]!=Mt?je:Ke}}),l.$on("click",e[9]);var T=e[1].component;return T&&(f=new T({props:{}}),e[10](f)),{c(){t=m("div"),i=m("header"),n=m("ul");for(let e=0;e<w.length;e+=1)w[e].c();r=g(),o=m("div"),W(a.$$.fragment),s=g(),W(l.$$.fragment),u=g(),b=m("div"),f&&W(f.$$.fragment),x(o,"class","buttons svelte-bkw2mk"),x(i,"class","svelte-bkw2mk"),x(b,"class","content svelte-bkw2mk"),x(t,"class","container svelte-bkw2mk"),k(t,"collapsed",e[0]==Mt),k(t,"fullscreen",e[0]==At)},m(e,c){p(e,t,c),d(t,i),d(i,n);for(let e=0;e<w.length;e+=1)w[e].m(n,null);d(i,r),d(i,o),X(a,o,null),d(o,s),X(l,o,null),d(t,u),d(t,b),f&&X(f,b,null),y=!0},p(e,[i]){if(74&i){let t;for(v=e[3],t=0;t<v.length;t+=1){const r=Et(e,v,t);w[t]?(w[t].p(r,i),U(w[t],1)):(w[t]=Pt(r),w[t].c(),U(w[t],1),w[t].m(n,null))}for(D(),t=v.length;t<w.length;t+=1)C(t);F()}const r={};1&i&&(r.icon=e[0]!=At?Qe:Ze),a.$set(r);const o={};1&i&&(o.icon=e[0]!=Mt?je:Ke),l.$set(o);const s={};if(T!==(T=e[1].component)){if(f){D();const e=f;_(e.$$.fragment,1,0,()=>{Y(e,1)}),F()}T?(f=new T({props:{}}),e[10](f),W(f.$$.fragment),U(f.$$.fragment,1),X(f,b,null)):f=null}else T&&f.$set(s);1&i&&k(t,"collapsed",e[0]==Mt),1&i&&k(t,"fullscreen",e[0]==At)},i(e){if(!y){for(let e=0;e<v.length;e+=1)U(w[e]);U(a.$$.fragment,e),U(l.$$.fragment,e),f&&U(f.$$.fragment,e),y=!0}},o(e){w=w.filter(Boolean);for(let e=0;e<w.length;e+=1)_(w[e]);_(a.$$.fragment,e),_(l.$$.fragment,e),f&&_(f.$$.fragment,e),y=!1},d(i){i&&c(t),h(w,i),Y(a),Y(l),e[10](null),f&&Y(f)}}}const At="fullscreen",Mt="collapsed";function Ot(e,t,i){let n,r=Mt,o=[{label:"Images",component:yt,icon:it},{label:"Viewer",component:Tt,icon:et},{label:"Library",component:Rt,icon:qe},{label:"Export",component:ct,icon:tt}],a=o[0];function s(){i(0,r=r==Mt?"open":Mt)}function l(){i(0,r=r==At?"open":At)}function u(e){r==Mt&&i(0,r="open"),i(1,a=e)}return e.$$.update=()=>{5&e.$$.dirty&&function(e,t){setTimeout(()=>{e&&e.refresh&&e.refresh()},10)}(n)},[r,a,n,o,s,l,u,e=>u(e),()=>l(),()=>s(),function(e){E[e?"unshift":"push"](()=>{n=e,i(2,n)})}]}var Lt=class extends K{constructor(e){super(),j(this,e,Ot,Bt,l,{})}};i(20);function Gt(e){let t,i,r,o;return r=new Lt({}),{c(){t=m("div"),i=g(),W(r.$$.fragment),x(t,"class","editor svelte-7hk7a9")},m(n,a){p(n,t,a),e[3](t),p(n,i,a),X(r,n,a),o=!0},p:n,i(e){o||(U(r.$$.fragment,e),o=!0)},o(e){_(r.$$.fragment,e),o=!1},d(n){n&&c(t),e[3](null),n&&c(i),Y(r,n)}}}function zt(e,t,i){let n,r,{nodeGroup:o={nodes:[],connections:[]}}=t;return S(()=>{r=new q.GraphEditor({container:n,graphicalHelper:De,nodeFactory:Fe}),r.onGraphChange(e=>{ve.set(e)}),r.load(o)}),e.$$set=e=>{"nodeGroup"in e&&i(1,o=e.nodeGroup)},[n,o,function(e){r.updatePreviews(e)},function(e){E[e?"unshift":"push"](()=>{n=e,i(0,n)})}]}var Nt=class extends K{constructor(e){super(),j(this,e,zt,Gt,l,{nodeGroup:1,updatePreviews:2})}get updatePreviews(){return this.$$.ctx[2]}};const It=new Map;Ne.forEach(e=>It.set(e.nodeDefinition.id,e));class Ht{constructor(){this.dirty=!0,this.value=null}update(e){this.value!=e&&(this.value=e,this.dirty=!0)}}class Vt{constructor(e){this.property=e,this.dirty=!0}update(e){this.output!=e&&(this.output=e,this.dirty=!0),null==this.output&&this.value!=this.property.value&&(this.dirty=!0,this.value=this.property.value)}isDirty(){return this.output?this.dirty||this.output.dirty:this.dirty}getValue(){return this.output?this.output.value:this.property.value}}class Dt{constructor(e){this.node=e,this.needEvaluation=!0,this.outputs=new Map,this.previous=[],this.inputs=new Map,this.node.properties.forEach(e=>{e.definition.type==q.PropertyType.OUTPUT?this.outputs.set(e,new Ht):this.inputs.set(e,new Vt(e))})}link(e){this.previous=[],this.node.properties.filter(e=>e.definition.type==q.PropertyType.INPUT).forEach(t=>{if(t.isConnected()){const i=t.connections[0].opposite(t),n=e.get(i.node);this.previous.push(n),this.inputs.get(t).update(n.outputs.get(i))}else this.inputs.get(t).update(null)})}evaluate(e){if(this.updateNeedEvaluation(),this.needEvaluation){const t={};for(let[e,i]of this.inputs.entries())t[e.definition.id]=i.getValue();const{outputs:i,preview:n}=function(e,t){const i=It.get(e);return i?i.evaluate(t):(console.log("Unknown processor",e),{outputs:{}})}(this.node.definition.id,t);n&&(e[this.node.id]=n);for(let[e,t]of this.outputs.entries())t.update(i[e.definition.id]);for(let e of this.inputs.values())e.dirty=!1}this.needEvaluation=!1}clearOutputsDirty(){for(let[e,t]of this.outputs.entries())t.dirty=!1}updateNeedEvaluation(){this.inputs.forEach(e=>{e.isDirty()&&(this.needEvaluation=!0)}),this.needEvaluation}}class Ft{constructor(){this.instances=[]}update(e){let t=new Map;this.instances.forEach(e=>t.set(e.node,e)),this.instances=e.nodes.map(e=>{const i=t.get(e);return i||new Dt(e)}),this.instances.forEach(e=>t.set(e.node,e)),this.instances.forEach(e=>e.link(t));const i=this.instances.slice();for(this.instances=[];i.length>0;){const e=i.pop();e.previous.every(e=>this.instances.indexOf(e)>=0)?this.instances.push(e):i.unshift(e)}let n={};return this.instances.forEach(e=>{e.evaluate(n)}),this.instances.forEach(e=>{e.clearOutputsDirty()}),n}}const Ut={nodes:[{id:"FJ8sC5WLpeG3JWTB",type:"image-input",location:{x:108,y:94}},{id:"K7QgCKFgVZMTZRlb",type:"grayscale",location:{x:424,y:95}},{id:"t2Gh6eV8FQlfScyn",type:"histogram",location:{x:789,y:238}},{id:"qxjiXBXQjBQ8X0gO",type:"otsu-levels",location:{x:1063,y:248}},{id:"UAcQamo0C8WTZ2U0",type:"binarization",location:{x:1648,y:84},properties:{level:128}},{id:"xLufrl0nUyowLQ84",type:"argmax",location:{x:1315,y:250}},{id:"jZZLlickOSB067dk",type:"viewer",location:{x:2404.892693187014,y:-61.60757201646109},fullWidth:533.2460051821372},{id:"V9r9MatMr7wyzkzB",type:"chart-viewer",location:{x:1063.4244779759183,y:495.09525986892226},fullWidth:336.8388965096783},{id:"9XtIpUBUt3gJ8uzC",type:"marching-squares",location:{x:1909.3321140070113,y:440.22557536960835}},{id:"Cy71G5p9sXI9EQHi",type:"blob-hierarchy",location:{x:2176.059746989787,y:446.3222069806434},properties:{"filter-blobs":!0}}],connections:[{from:{node:"FJ8sC5WLpeG3JWTB",property:"image"},to:{node:"K7QgCKFgVZMTZRlb",property:"input"}},{from:{node:"K7QgCKFgVZMTZRlb",property:"output"},to:{node:"t2Gh6eV8FQlfScyn",property:"image"}},{from:{node:"K7QgCKFgVZMTZRlb",property:"output"},to:{node:"UAcQamo0C8WTZ2U0",property:"input"}},{from:{node:"t2Gh6eV8FQlfScyn",property:"histogram"},to:{node:"qxjiXBXQjBQ8X0gO",property:"histogram"}},{from:{node:"t2Gh6eV8FQlfScyn",property:"histogram"},to:{node:"V9r9MatMr7wyzkzB",property:"values"}},{from:{node:"qxjiXBXQjBQ8X0gO",property:"levels"},to:{node:"xLufrl0nUyowLQ84",property:"values"}},{from:{node:"UAcQamo0C8WTZ2U0",property:"output"},to:{node:"9XtIpUBUt3gJ8uzC",property:"image"}},{from:{node:"UAcQamo0C8WTZ2U0",property:"output"},to:{node:"jZZLlickOSB067dk",property:"image"}},{from:{node:"xLufrl0nUyowLQ84",property:"value"},to:{node:"UAcQamo0C8WTZ2U0",property:"level"}},{from:{node:"9XtIpUBUt3gJ8uzC",property:"outlines"},to:{node:"Cy71G5p9sXI9EQHi",property:"outlines"}},{from:{node:"Cy71G5p9sXI9EQHi",property:"blobs"},to:{node:"jZZLlickOSB067dk",property:"marks"}}],canvas:{position:{x:136.73647309861303,y:-120.66453284560276},zoom:.6560999999999999}};i(22);function _t(e){let t,i;return t=new Nt({props:{nodeGroup:Ut}}),e[1](t),{c(){W(t.$$.fragment)},m(e,n){X(t,e,n),i=!0},p(e,[i]){t.$set({})},i(e){i||(U(t.$$.fragment,e),i=!0)},o(e){_(t.$$.fragment,e),i=!1},d(i){e[1](null),Y(t,i)}}}function $t(e,t,i){let n,r=new Ft;return S(()=>(Promise.all([ht.loadURL("alice.jpg","alice.jpg"),ht.loadURL("lines.jpg","lines.jpg")]).then(e=>{ke.set(e)},e=>{console.log("ERROR loading",e)}),ve.subscribe(e=>{const t=r.update(e);n.updatePreviews(t)}))),[n,function(e){E[e?"unshift":"push"](()=>{n=e,i(0,n)})}]}const Wt=new class extends K{constructor(e){super(),j(this,e,$t,_t,l,{})}}({target:document.body});t.default=Wt}]);